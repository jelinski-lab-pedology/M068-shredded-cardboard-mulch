---
title: "Crop productivity analysis"
---

## Packages

```{r}
library(tidyr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(here)
library(MASS) #boxcox transformation
library(lme4)         #mixed models
library(lmerTest)     #mixed models
library(broom.mixed)  #mixed models
library(emmeans)
```

## Loading Data

```{r}
yield <- read.csv(here::here("00-data", "b-prepared", 
                             "20250725_SCM-yield.csv"), 
                      header = TRUE)

spad <- read.csv(here::here("00-data", "b-prepared", 
                            "20250716_SCM-SPAD.csv"), 
                     header = TRUE)

```

## Format Data

### yield
```{r}
#Move edge data into a separate dataframe
edge <- subset(yield, block == "edge")
biomass <- subset(yield, is.na(biomass_g) == FALSE)

#overall formatting
yield <- yield %>%
        subset(block != 5) %>%
        subset(block != "edge") %>%
        dplyr::select(-notes, biomass_g) %>%
        mutate(date_collected = lubridate::as_date(date_collected, 
                                                   format = "%m/%d/%Y"),
               year = lubridate::isoyear(ymd(date_collected)),
               month = lubridate::month(date_collected),
               week = lubridate::isoweek(ymd(date_collected))) %>%
        mutate_at(c('block', 'plot', 'treatment', 
                    'crop', "year", "week", "month"), 
                  as.factor) %>%
        group_by(date_collected, week, month, year, 
                 block, plot, treatment, crop) %>%
        summarize(marketable_g = sum(marketable_g, na.rm = TRUE),
                  unmarketable_g = sum(unmarketable_g, na.rm = TRUE),
                  total_g = sum(total_g, na.rm = TRUE),
                  per_market = (marketable_g/total_g)*100,
                  per_unmarket = (unmarketable_g/total_g)*100) %>%
        ungroup

# calculating the total yield per week for each plot
# mostly impacts 2023, when we occassionally harvested 2x per week
yield_wk <- yield %>%
            group_by(week, year, block, plot, treatment, crop) %>%
            summarize(marketable_g = sum(marketable_g, na.rm = TRUE),
                      unmarketable_g = sum(unmarketable_g, na.rm = TRUE),
                      total_g = sum(total_g, na.rm = TRUE),
                      per_market = (marketable_g/total_g)*100,
                      per_unmarket = (unmarketable_g/total_g)*100) %>%
            ungroup

# separate data frames for the weekly yield data for each crop
yield_wk_AS <- subset(yield_wk, crop == "AS" & total_g != 0)
yield_wk_23_AS <- subset(yield_wk_AS, year == "2023")
yield_wk_24_AS <- subset(yield_wk_AS, year == "2024")

yield_wk_DB <- subset(yield_wk, crop == "DB" & total_g != 0)
yield_wk_23_DB <- subset(yield_wk_DB, year == "2023")
yield_wk_24_DB <- subset(yield_wk_DB, year == "2024")

yield_wk_FC <- subset(yield_wk, crop == "FC" & total_g != 0)
yield_wk_23_FC <- subset(yield_wk_FC, year == "2023")
yield_wk_24_FC <- subset(yield_wk_FC, year == "2024")

# calculating annual yield for each plot
yield_yr <- yield %>%
            group_by(year, block, plot, treatment, crop) %>%
            summarize(marketable_g = sum(marketable_g, na.rm = TRUE),
                      unmarketable_g = sum(unmarketable_g, na.rm = TRUE),
                      total_g = sum(total_g, na.rm = TRUE),
                      per_market = (marketable_g/total_g)*100,
                      per_unmarket = (unmarketable_g/total_g)*100) %>%
            ungroup

# separate data frames for the annual yield for each crop

yield_yr_AS <- subset(yield_yr, crop == "AS")
yield_23_AS <- subset(yield_yr_AS, year == "2023")
yield_24_AS <- subset(yield_yr_AS, year == "2024")

yield_yr_DB <- subset(yield_yr, crop == "DB")
yield_23_DB <- subset(yield_yr_DB, year == "2023")
yield_24_DB <- subset(yield_yr_DB, year == "2024")

yield_yr_FC <- subset(yield_yr, crop == "FC")
yield_23_FC <- subset(yield_yr_FC, year == "2023")
yield_24_FC <- subset(yield_yr_FC, year == "2024")
```


### SPAD
```{r}

spad <- spad %>%
        subset(block != 5) %>% 
        dplyr::select(-average_reading) %>%
        mutate(date_collected = lubridate::as_date(date_collected, format = "%m/%d/%Y"),
               year = lubridate::isoyear(ymd(date_collected))) %>%
        pivot_longer(cols = c("reading_1", "reading_2", "reading_3"),
                     names_to = "reading",
                     values_to = "value") %>%
        mutate_at(c('sampling','block', 'plot', 'treatment', 'crop', "year"), as.factor)

spad_AS <- subset(spad, crop == "AS")
spad_DB <- subset(spad, crop == "DB")
spad_FC <- subset(spad, crop == "FC")
```

## Outlier checks

### Weekly yield

#### Strawberries

##### Marketable

There are six outliers, from weeks 34-36 in 2023, all above the upper bound. We had a really productive second harvest of strawberries--Nora was harvesting SO MANY--so while outside the normal range, I trust the data
```{r}
Q1 <- quantile(yield_wk_AS$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_AS$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_AS$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_AS, yield_wk_AS$marketable_g > upper_bound | 
                    yield_wk_AS$marketable_g < lower_bound)
```

##### Percent marketable

There are 25 potential outliers, all less than the lower bound (and most 0%). But, all were representative of real world conditions.

```{r}
Q1 <- quantile(yield_wk_AS$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_AS$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_AS$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_AS, yield_wk_AS$per_market > upper_bound | 
                    yield_wk_AS$per_market < lower_bound)
```

##### Unmarketable

There were 19 potential outliers, all higher than the upper bound. Most of the very high ones (like 5x the upper bound) were in 2023 during the second strawberry harvest. The rest were relatively close to the upper bound (only a couple grams higher)
```{r}
Q1 <- quantile(yield_wk_AS$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_AS$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_AS$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_AS, yield_wk_AS$unmarketable_g > upper_bound | 
                    yield_wk_AS$unmarketable_g < lower_bound)
```

##### Total

There were 5 potential outliers, several the same as marketable yield, for the large late-season harvest.
```{r}
Q1 <- quantile(yield_wk_AS$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_AS$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_AS$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_AS, yield_wk_AS$total_g > upper_bound | 
                    yield_wk_AS$total_g < lower_bound)
```

#### Beans

##### Marketable

There were 8 potential outliers, all from the week we had just a truly overwhelming harvest in August (and we were harvesting heavily, as well, for a slew of upcoming neighborhood events)
```{r}
Q1 <- quantile(yield_wk_DB$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_DB$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_DB$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_DB, yield_wk_DB$marketable_g > upper_bound | 
                    yield_wk_DB$marketable_g < lower_bound)
```

##### Percent marketable

Three potential outliers, all just slightly less than 100% -- and they're find because while there were very few unmarketable beans, they did happen occassionally
```{r}
Q1 <- quantile(yield_wk_DB$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_DB$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_DB$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_DB, yield_wk_DB$per_market > upper_bound | 
                    yield_wk_DB$per_market < lower_bound)
```

##### Unmarketable

Same three outliers as identified above
```{r}
Q1 <- quantile(yield_wk_DB$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_DB$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_DB$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_DB, yield_wk_DB$unmarketable_g > upper_bound | 
                    yield_wk_DB$unmarketable_g < lower_bound)
```

##### Total

Eight potential outliers, the same as identified for marketable
```{r}
Q1 <- quantile(yield_wk_DB$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_DB$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_DB$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_DB, yield_wk_DB$total_g > upper_bound | 
                    yield_wk_DB$total_g < lower_bound)
```

#### Collards

##### Marketable

There are 21 potential outliers, all from 2024. Half are close to the upper bound, and the other half are from the last days of harvest, after they hadn't been harvested for a month
```{r}
Q1 <- quantile(yield_wk_FC$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_FC$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_FC$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_FC, yield_wk_FC$marketable_g > upper_bound | 
                    yield_wk_FC$marketable_g < lower_bound)
```

##### Percent marketable
There are no outliers
```{r}
Q1 <- quantile(yield_wk_FC$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_FC$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_FC$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_FC, yield_wk_FC$per_market > upper_bound | 
                    yield_wk_FC$per_market < lower_bound)
```

##### Unmarketable

There are 20 potential outliers, all from 2024, but none of them give me any reason to think they're out of place
```{r}
Q1 <- quantile(yield_wk_FC$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_FC$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_FC$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_FC, yield_wk_FC$unmarketable_g > upper_bound | 
                    yield_wk_FC$unmarketable_g < lower_bound)
```

##### Total
22 rows, again, all from 2024
```{r}
Q1 <- quantile(yield_wk_FC$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_wk_FC$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_wk_FC$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_wk_FC, yield_wk_FC$total_g > upper_bound | 
                    yield_wk_FC$total_g < lower_bound)
```

### Annual yield
The outlier analysis for individual weeks is more important but doing it here for due diligence. 

#### Strawberries

##### Marketable
There are no outliers
```{r}
Q1 <- quantile(yield_yr_AS$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_AS$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_AS$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_AS, yield_yr_AS$marketable_g > upper_bound | 
                    yield_yr_AS$marketable_g < lower_bound)
```

##### Percent marketable

Four potential outliers, all less than the lower_bound, but most are bare soil and seem to be due to low overall yields
```{r}
Q1 <- quantile(yield_yr_AS$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_AS$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_AS$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_AS, yield_yr_AS$per_market > upper_bound | 
                    yield_yr_AS$per_market < lower_bound)
```

##### Unmarketable

One potential outlier, but seems to just be a generally highly productive plot (and it isn't much higher than the upper bound)
```{r}
Q1 <- quantile(yield_yr_AS$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_AS$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_AS$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_AS, yield_yr_AS$unmarketable_g > upper_bound | 
                    yield_yr_AS$unmarketable_g < lower_bound)
```

##### Total
There are no outliers
```{r}
Q1 <- quantile(yield_yr_AS$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_AS$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_AS$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_AS, yield_yr_AS$total_g > upper_bound | 
                    yield_yr_AS$total_g < lower_bound)
```

#### Beans

##### Marketable
There are no outliers
```{r}
Q1 <- quantile(yield_yr_DB$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_DB$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_FC$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_DB, yield_yr_DB$marketable_g > upper_bound | 
                    yield_yr_DB$marketable_g < lower_bound)
```

##### Percent marketable

Three potential outliers, all of which are just not 100%, which was the case for almost every plot
```{r}
Q1 <- quantile(yield_yr_DB$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_DB$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_DB$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_DB, yield_yr_DB$per_market > upper_bound | 
                    yield_yr_DB$per_market < lower_bound)
```

##### Unmarketable
Same three plots as above, not concerned
```{r}
Q1 <- quantile(yield_yr_DB$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_DB$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_DB$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_DB, yield_yr_DB$unmarketable_g > upper_bound | 
                    yield_yr_DB$unmarketable_g < lower_bound)
```

##### Total
There are no outliers
```{r}
Q1 <- quantile(yield_yr_DB$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_DB$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_DB$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_DB, yield_yr_DB$total_g > upper_bound | 
                    yield_yr_DB$total_g < lower_bound)
```

#### Collards

##### Marketable

One potential outlier, in 2024, and I can tell you from memory that it was the plot with all the ridiculously large collard plants
```{r}
Q1 <- quantile(yield_yr_FC$marketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_FC$marketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_FC$marketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_FC, yield_yr_FC$marketable_g > upper_bound | 
                    yield_yr_FC$marketable_g < lower_bound)
```

##### Percent marketable
There are no outliers
```{r}
Q1 <- quantile(yield_yr_FC$per_market, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_FC$per_market, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_FC$per_market,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_FC, yield_yr_FC$per_market > upper_bound | 
                    yield_yr_FC$per_market < lower_bound)
```

##### Unmarketable
There are no outliers
```{r}
Q1 <- quantile(yield_yr_FC$unmarketable_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_FC$unmarketable_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_FC$unmarketable_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_FC, yield_yr_FC$unmarketable_g > upper_bound | 
                    yield_yr_FC$unmarketable_g < lower_bound)
```

##### Total
There are no outliers
```{r}
Q1 <- quantile(yield_yr_FC$total_g, 0.25, na.rm = TRUE) 
Q3 <- quantile(yield_yr_FC$total_g, 0.75, na.rm = TRUE) 
IQR <- IQR(yield_yr_FC$total_g,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

subset(yield_yr_FC, yield_yr_FC$total_g > upper_bound | 
                    yield_yr_FC$total_g < lower_bound)
```

### SPAD

#### Strawberries

There are 26 potential outliers. Except for a plant where all three readings were high in 1-B on 7/16/2024, others were individually elevated readings. Only one one was lower than the lower bound. 
```{r}
Q1 <- quantile(spad_AS$value, 0.25, na.rm = TRUE) 
Q3 <- quantile(spad_AS$value, 0.75, na.rm = TRUE) 
IQR <- IQR(spad_AS$value,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

spad_AS %>% subset(value > upper_bound | value < lower_bound)

#saving a df with outliers for comparison
spad_AS_out <- spad_AS

#outliers removed
spad_AS <- spad_AS %>%
           subset(value > lower_bound & value < upper_bound)

```

#### Beans

Wowza, 78 potential outliers identified. I'm tempted to do the same here, where I adjust the range a little to keep > 10 and < 50
```{r}
Q1 <- quantile(spad_DB$value, 0.25, na.rm = TRUE) 
Q3 <- quantile(spad_DB$value, 0.75, na.rm = TRUE) 
IQR <- IQR(spad_DB$value,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

spad_DB %>% subset(value > upper_bound | value < lower_bound)

#saving a df with outliers for comparison
spad_DB_out <- spad_DB

#outliers removed
spad_DB <- spad_DB %>%
           subset(value > lower_bound & value < upper_bound)

```

#### Collards
88 potential outliers! All but one above the upper bound. I feel more comfortable removing that one. 
```{r}
Q1 <- quantile(spad_FC$value, 0.25, na.rm = TRUE) 
Q3 <- quantile(spad_FC$value, 0.75, na.rm = TRUE) 
IQR <- IQR(spad_FC$value,na.rm = TRUE)

lower_bound <- Q1 - (1.5*IQR)
upper_bound <- Q3 + (1.5*IQR)

spad_FC %>% subset(value > upper_bound | value < lower_bound)

#saving a df with outliers for comparison
spad_FC_out <- spad_FC

#outliers removed
spad_FC <- spad_FC %>%
           subset(value > lower_bound & value < upper_bound)

```

## Normality and Transformations

### Weekly yield

#### Strawberries

##### Marketable yield

The original dataset is non-parametric, with a lambda between 0 and 0.5 which indicates a log, sqrt, or boxcox transformation will be most appropriate. None achieves a normal distribution
```{r}
#original dataset
hist(yield_wk_AS$marketable_g)
skewness(yield_wk_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_wk_AS$marketable_g, main='Normal')
qqline(yield_wk_AS$marketable_g)
shapiro.test(yield_wk_AS$marketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_AS$marketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_AS$bc_marketable <- ((yield_wk_AS$marketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_AS$bc_marketable)
skewness(yield_wk_AS$bc_marketable, na.rm = TRUE)
qqnorm(yield_wk_AS$bc_marketable, main='Normal')
qqline(yield_wk_AS$bc_marketable)
shapiro.test(yield_wk_AS$bc_marketable)

#log
yield_wk_AS$log_marketable <- log10(yield_wk_AS$marketable_g + 1)

hist(yield_wk_AS$log_marketable)
skewness(yield_wk_AS$log_marketable, na.rm = TRUE)
qqnorm(yield_wk_AS$log_marketable, main='Normal')
qqline(yield_wk_AS$log_marketable)
shapiro.test(yield_wk_AS$log_marketable)

#sqrt
yield_wk_AS$sqrt_marketable <- sqrt(yield_wk_AS$marketable_g + 1)

hist(yield_wk_AS$sqrt_marketable)
skewness(yield_wk_AS$sqrt_marketable, na.rm = TRUE)
qqnorm(yield_wk_AS$sqrt_marketable, main='Normal')
qqline(yield_wk_AS$sqrt_marketable)
shapiro.test(yield_wk_AS$sqrt_marketable)
```

2023 only: The original dataset is non-parametric, with a lambda between 0 and 0.5 which indicates a log, sqrt, or boxcox transformation will be most appropriate. The boxcox is the only one that achieves a normal distribution
```{r}
#original dataset
hist(yield_wk_23_AS$marketable_g)
skewness(yield_wk_23_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_wk_23_AS$marketable_g, main='Normal')
qqline(yield_wk_23_AS$marketable_g)
shapiro.test(yield_wk_23_AS$marketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_23_AS$marketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_23_AS$bc_marketable <- ((yield_wk_23_AS$marketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_23_AS$bc_marketable)
skewness(yield_wk_23_AS$bc_marketable, na.rm = TRUE)
qqnorm(yield_wk_23_AS$bc_marketable, main='Normal')
qqline(yield_wk_23_AS$bc_marketable)
shapiro.test(yield_wk_23_AS$bc_marketable)

#log
#yield_wk_23_AS$log_marketable <- log10(yield_wk_23_AS$marketable_g + 1)
#shapiro.test(yield_wk_23_AS$log_marketable)

#sqrt
#yield_wk_23_AS$sqrt_marketable <- sqrt(yield_wk_23_AS$marketable_g + 1)
#shapiro.test(yield_wk_23_AS$sqrt_marketable)
```

2024 only: The original dataset is non-parametric with a lambda close to 0, indicating a boxcox or log transformation will be most appropriate. Neither achieves a normal distribution
```{r}
#original dataset
hist(yield_wk_24_AS$marketable_g)
skewness(yield_wk_24_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_wk_24_AS$marketable_g, main='Normal')
qqline(yield_wk_24_AS$marketable_g)
shapiro.test(yield_wk_24_AS$marketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_24_AS$marketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_24_AS$bc_marketable <- ((yield_wk_24_AS$marketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_24_AS$bc_marketable)
skewness(yield_wk_24_AS$bc_marketable, na.rm = TRUE)
qqnorm(yield_wk_24_AS$bc_marketable, main='Normal')
qqline(yield_wk_24_AS$bc_marketable)
shapiro.test(yield_wk_24_AS$bc_marketable)

#log
yield_wk_24_AS$log_marketable <- log10(yield_wk_24_AS$marketable_g + 1)

hist(yield_wk_24_AS$log_marketable)
skewness(yield_wk_24_AS$log_marketable, na.rm = TRUE)
qqnorm(yield_wk_24_AS$log_marketable, main='Normal')
qqline(yield_wk_24_AS$log_marketable)
shapiro.test(yield_wk_24_AS$log_marketable)

```

##### Percent Marketable

The original dataset is non-parametric, with a lambda between 1 and 2, indicating that a squared, cubic, or boxcox transformation would be most appropriate. None of them achieve a normal distribution, though
```{r}
#original dataset
hist(yield_wk_AS$per_market)
skewness(yield_wk_AS$per_market, na.rm = TRUE)
qqnorm(yield_wk_AS$per_market, main='Normal')
qqline(yield_wk_AS$per_market)
shapiro.test(yield_wk_AS$per_market)

#boxcox
bc <- boxcox(lm((yield_wk_AS$per_market + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_AS$bc_per <- ((yield_wk_AS$per_market + 1) ^ lambda -1)/lambda

hist(yield_wk_AS$bc_per)
skewness(yield_wk_AS$bc_per, na.rm = TRUE)
qqnorm(yield_wk_AS$bc_per, main='Normal')
qqline(yield_wk_AS$bc_per)
shapiro.test(yield_wk_AS$bc_per)

#squared
yield_wk_AS$sq_per <- (yield_wk_AS$per_market)^2

hist(yield_wk_AS$sq_per)
skewness(yield_wk_AS$sq_per, na.rm = TRUE)
qqnorm(yield_wk_AS$sq_per, main='Normal')
qqline(yield_wk_AS$sq_per)
shapiro.test(yield_wk_AS$sq_per)

#sqrt
yield_wk_AS$cubic_per <- yield_wk_AS$per_market^3

hist(yield_wk_AS$cubic_per)
skewness(yield_wk_AS$cubic_per, na.rm = TRUE)
qqnorm(yield_wk_AS$cubic_per, main='Normal')
qqline(yield_wk_AS$cubic_per)
shapiro.test(yield_wk_AS$cubic_per)
```
2023 only: The original dataset is non-parametric with a lambda of 2, indicating that a squared, cubic, or boxcox transformation would be most appropriate. None achieve a normal distribution
```{r}
#original dataset
hist(yield_wk_23_AS$per_market)
skewness(yield_wk_23_AS$per_market, na.rm = TRUE)
qqnorm(yield_wk_23_AS$per_market, main='Normal')
qqline(yield_wk_23_AS$per_market)
shapiro.test(yield_wk_23_AS$per_market)

#boxcox
bc <- boxcox(lm((yield_wk_23_AS$per_market + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_23_AS$bc_per <- ((yield_wk_23_AS$per_market + 1) ^ lambda -1)/lambda

hist(yield_wk_23_AS$bc_per)
skewness(yield_wk_23_AS$bc_per, na.rm = TRUE)
qqnorm(yield_wk_23_AS$bc_per, main='Normal')
qqline(yield_wk_23_AS$bc_per)
shapiro.test(yield_wk_23_AS$bc_per)

#squared
yield_wk_23_AS$sq_per <- (yield_wk_23_AS$per_market)^2

hist(yield_wk_23_AS$sq_per)
skewness(yield_wk_23_AS$sq_per, na.rm = TRUE)
qqnorm(yield_wk_23_AS$sq_per, main='Normal')
qqline(yield_wk_23_AS$sq_per)
shapiro.test(yield_wk_23_AS$sq_per)

#cubic
yield_wk_23_AS$cubic_per <- yield_wk_23_AS$per_market^3

hist(yield_wk_23_AS$cubic_per)
skewness(yield_wk_23_AS$cubic_per, na.rm = TRUE)
qqnorm(yield_wk_23_AS$cubic_per, main='Normal')
qqline(yield_wk_23_AS$cubic_per)
shapiro.test(yield_wk_23_AS$cubic_per)
```

2024 only: The original dataset is non-parametric, with a lambda between 0.5 and 1 indicating that a sqrt or boxcox transformation would be most appropriate. Neither achieves a normal distribution
```{r}
#original dataset
hist(yield_wk_24_AS$per_market)
skewness(yield_wk_24_AS$per_market, na.rm = TRUE)
qqnorm(yield_wk_24_AS$per_market, main='Normal')
qqline(yield_wk_24_AS$per_market)
shapiro.test(yield_wk_24_AS$per_market)

#boxcox
bc <- boxcox(lm((yield_wk_24_AS$per_market + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_24_AS$bc_per <- ((yield_wk_24_AS$per_market + 1) ^ lambda -1)/lambda

hist(yield_wk_24_AS$bc_per)
skewness(yield_wk_24_AS$bc_per, na.rm = TRUE)
qqnorm(yield_wk_24_AS$bc_per, main='Normal')
qqline(yield_wk_24_AS$bc_per)
shapiro.test(yield_wk_24_AS$bc_per)

#sqrt
yield_wk_AS$sqrt_per <- sqrt(yield_wk_AS$per_market)

hist(yield_wk_AS$sqrt_per)
skewness(yield_wk_AS$sqrt_per, na.rm = TRUE)
qqnorm(yield_wk_AS$sqrt_per, main='Normal')
qqline(yield_wk_AS$sqrt_per)
shapiro.test(yield_wk_AS$sqrt_per)

```

##### Unmarketable yield

The original dataset is non-parametric, with a lambda between -0.5 and 0 indicating an inverse sqrt, log, or boxcox would be most appropriate. None results in a normal distribution
```{r}
#original dataset
hist(yield_wk_AS$unmarketable_g)
skewness(yield_wk_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_wk_AS$unmarketable_g, main='Normal')
qqline(yield_wk_AS$unmarketable_g)
shapiro.test(yield_wk_AS$unmarketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_AS$unmarketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_AS$bc_unmarketable <- ((yield_wk_AS$unmarketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_AS$bc_unmarketable)
skewness(yield_wk_AS$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_AS$bc_unmarketable, main='Normal')
qqline(yield_wk_AS$bc_unmarketable)
shapiro.test(yield_wk_AS$bc_unmarketable)

#log
yield_wk_AS$log_unmarketable <- log10(yield_wk_AS$unmarketable_g + 1)

hist(yield_wk_AS$log_unmarketable)
skewness(yield_wk_AS$log_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_AS$log_unmarketable, main='Normal')
qqline(yield_wk_AS$log_unmarketable)
shapiro.test(yield_wk_AS$log_unmarketable)

#inverse sqrt
yield_wk_AS$in_sqrt_unmarketable <- 1/sqrt(yield_wk_AS$unmarketable_g + 1)

hist(yield_wk_AS$in_sqrt_unmarketable)
skewness(yield_wk_AS$in_sqrt_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_AS$in_sqrt_unmarketable, main='Normal')
qqline(yield_wk_AS$in_sqrt_unmarketable)
shapiro.test(yield_wk_AS$in_sqrt_unmarketable)
```

2023 only: The original dataset is non-parametric, with a lambda between -0.5 and 0 indicating an inverse sqrt, log, or boxcox would be most appropriate. None results in a normal distribution
```{r}
#original dataset
hist(yield_wk_23_AS$unmarketable_g)
skewness(yield_wk_23_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_wk_23_AS$unmarketable_g, main='Normal')
qqline(yield_wk_23_AS$unmarketable_g)
shapiro.test(yield_wk_23_AS$unmarketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_23_AS$unmarketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_23_AS$bc_unmarketable <- ((yield_wk_23_AS$unmarketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_23_AS$bc_unmarketable)
skewness(yield_wk_23_AS$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_23_AS$bc_unmarketable, main='Normal')
qqline(yield_wk_23_AS$bc_unmarketable)
shapiro.test(yield_wk_23_AS$bc_unmarketable)

#log
yield_wk_23_AS$log_unmarketable <- log10(yield_wk_23_AS$unmarketable_g + 1)

hist(yield_wk_23_AS$log_unmarketable)
skewness(yield_wk_23_AS$log_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_23_AS$log_unmarketable, main='Normal')
qqline(yield_wk_23_AS$log_unmarketable)
shapiro.test(yield_wk_23_AS$log_unmarketable)

#inverse sqrt
yield_wk_23_AS$in_sqrt_unmarketable <- 1/sqrt(yield_wk_23_AS$unmarketable_g + 1)

hist(yield_wk_23_AS$in_sqrt_unmarketable)
skewness(yield_wk_23_AS$in_sqrt_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_23_AS$in_sqrt_unmarketable, main='Normal')
qqline(yield_wk_23_AS$in_sqrt_unmarketable)
shapiro.test(yield_wk_23_AS$in_sqrt_unmarketable)
```

2024 only:The original dataset is non-parametric, with a lambda between -0.5 and 0 indicating an inverse sqrt, log, or boxcox would be most appropriate. None results in a normal distribution
```{r}
#original dataset
hist(yield_wk_24_AS$unmarketable_g)
skewness(yield_wk_24_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_wk_24_AS$unmarketable_g, main='Normal')
qqline(yield_wk_24_AS$unmarketable_g)
shapiro.test(yield_wk_24_AS$unmarketable_g)

#boxcox
bc <- boxcox(lm((yield_wk_24_AS$unmarketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_24_AS$bc_unmarketable <- ((yield_wk_24_AS$unmarketable_g + 1) ^ lambda -1)/lambda

hist(yield_wk_24_AS$bc_unmarketable)
skewness(yield_wk_24_AS$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_24_AS$bc_unmarketable, main='Normal')
qqline(yield_wk_24_AS$bc_unmarketable)
shapiro.test(yield_wk_24_AS$bc_unmarketable)

#log
yield_wk_24_AS$log_unmarketable <- log10(yield_wk_24_AS$unmarketable_g + 1)

hist(yield_wk_24_AS$log_unmarketable)
skewness(yield_wk_24_AS$log_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_24_AS$log_unmarketable, main='Normal')
qqline(yield_wk_24_AS$log_unmarketable)
shapiro.test(yield_wk_24_AS$log_unmarketable)

#inverse sqrt
yield_wk_24_AS$in_sqrt_unmarketable <- 1/sqrt(yield_wk_24_AS$unmarketable_g + 1)

hist(yield_wk_24_AS$in_sqrt_unmarketable)
skewness(yield_wk_24_AS$in_sqrt_unmarketable, na.rm = TRUE)
qqnorm(yield_wk_24_AS$in_sqrt_unmarketable, main='Normal')
qqline(yield_wk_24_AS$in_sqrt_unmarketable)
shapiro.test(yield_wk_24_AS$in_sqrt_unmarketable)
```

##### Total yield
Closest to a normal distribution, still not quite there
```{r}
hist(yield_AS$total_g)
skewness(yield_AS$total_g, na.rm = TRUE)
qqnorm(yield_AS$total_g, main='Normal')
qqline(yield_AS$total_g)
shapiro.test(yield_AS$total_g)

```

```{r}
bc <- boxcox(lm(yield_AS$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_AS$bc_total <- (yield_AS$total_g ^ lambda -1)/lambda

hist(yield_AS$bc_total)
skewness(yield_AS$bc_total, na.rm = TRUE)
qqnorm(yield_AS$bc_total, main='Normal')
qqline(yield_AS$bc_total)
shapiro.test(yield_AS$bc_total)

```

Overall: The dataset is non-parametric, with a lambda between 0 and 0.5 indicating that a log, sqrt, or boxcox transformation would be most appropriate. None of them are successfull though
```{r}
#original dataset
hist(yield_wk_AS$total_g)
skewness(yield_wk_AS$total_g, na.rm = TRUE)
qqnorm(yield_wk_AS$total_g, main='Normal')
qqline(yield_wk_AS$total_g)
shapiro.test(yield_wk_AS$total_g)

#boxcox
bc <- boxcox(lm(yield_wk_AS$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_AS$bc_total <- (yield_wk_AS$total_g ^ lambda -1)/lambda

hist(yield_wk_AS$bc_total)
skewness(yield_wk_AS$bc_total, na.rm = TRUE)
qqnorm(yield_wk_AS$bc_total, main='Normal')
qqline(yield_wk_AS$bc_total)
shapiro.test(yield_wk_AS$bc_total)

#log
yield_wk_AS$log_total <- log10(yield_wk_AS$total_g)

hist(yield_wk_AS$log_total)
skewness(yield_wk_AS$log_total, na.rm = TRUE)
qqnorm(yield_wk_AS$log_total, main='Normal')
qqline(yield_wk_AS$log_total)
shapiro.test(yield_wk_AS$log_total)

#sqrt
yield_wk_AS$sqrt_total <- sqrt(yield_wk_AS$total_g)

hist(yield_wk_AS$sqrt_total)
skewness(yield_wk_AS$sqrt_total, na.rm = TRUE)
qqnorm(yield_wk_AS$sqrt_total, main='Normal')
qqline(yield_wk_AS$sqrt_total)
shapiro.test(yield_wk_AS$sqrt_total)
```

2023 only: The dataset is non-parametric, with a lambda between 0 and 0.5 indicating that a log, sqrt, or boxcox transformation would be most appropriate. The box cox manages it!
```{r}
#original dataset
hist(yield_wk_23_AS$total_g)
skewness(yield_wk_23_AS$total_g, na.rm = TRUE)
qqnorm(yield_wk_23_AS$total_g, main='Normal')
qqline(yield_wk_23_AS$total_g)
shapiro.test(yield_wk_23_AS$total_g)

#boxcox
bc <- boxcox(lm(yield_wk_23_AS$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_23_AS$bc_total <- (yield_wk_23_AS$total_g ^ lambda -1)/lambda

hist(yield_wk_23_AS$bc_total)
skewness(yield_wk_23_AS$bc_total, na.rm = TRUE)
qqnorm(yield_wk_23_AS$bc_total, main='Normal')
qqline(yield_wk_23_AS$bc_total)
shapiro.test(yield_wk_23_AS$bc_total)

#log
yield_wk_23_AS$log_total <- log10(yield_wk_23_AS$total_g)

hist(yield_wk_23_AS$log_total)
skewness(yield_wk_23_AS$log_total, na.rm = TRUE)
qqnorm(yield_wk_23_AS$log_total, main='Normal')
qqline(yield_wk_23_AS$log_total)
shapiro.test(yield_wk_23_AS$log_total)

#sqrt
yield_wk_23_AS$sqrt_total <- sqrt(yield_wk_23_AS$total_g)

hist(yield_wk_23_AS$sqrt_total)
skewness(yield_wk_23_AS$sqrt_total, na.rm = TRUE)
qqnorm(yield_wk_23_AS$sqrt_total, main='Normal')
qqline(yield_wk_23_AS$sqrt_total)
shapiro.test(yield_wk_23_AS$sqrt_total)
```

2024 only: The dataset is non-parametric, with a lambda between 0 and 0.5 indicating that a log, sqrt, or boxcox transformation would be most appropriate. The box cox manages it!
```{r}
#original dataset
hist(yield_wk_24_AS$total_g)
skewness(yield_wk_24_AS$total_g, na.rm = TRUE)
qqnorm(yield_wk_24_AS$total_g, main='Normal')
qqline(yield_wk_24_AS$total_g)
shapiro.test(yield_wk_24_AS$total_g)

#boxcox
bc <- boxcox(lm(yield_wk_24_AS$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_wk_24_AS$bc_total <- (yield_wk_24_AS$total_g ^ lambda -1)/lambda

hist(yield_wk_24_AS$bc_total)
skewness(yield_wk_24_AS$bc_total, na.rm = TRUE)
qqnorm(yield_wk_24_AS$bc_total, main='Normal')
qqline(yield_wk_24_AS$bc_total)
shapiro.test(yield_wk_24_AS$bc_total)

#log
yield_wk_24_AS$log_total <- log10(yield_wk_24_AS$total_g)

hist(yield_wk_24_AS$log_total)
skewness(yield_wk_24_AS$log_total, na.rm = TRUE)
qqnorm(yield_wk_24_AS$log_total, main='Normal')
qqline(yield_wk_24_AS$log_total)
shapiro.test(yield_wk_24_AS$log_total)

#sqrt
yield_wk_24_AS$sqrt_total <- sqrt(yield_wk_24_AS$total_g)

hist(yield_wk_24_AS$sqrt_total)
skewness(yield_wk_24_AS$sqrt_total, na.rm = TRUE)
qqnorm(yield_wk_24_AS$sqrt_total, main='Normal')
qqline(yield_wk_24_AS$sqrt_total)
shapiro.test(yield_wk_24_AS$sqrt_total)
```

#### Beans

##### Marketable yield
Normally distributed!
```{r}

#original dataset
hist(yield_DB$marketable_g)
skewness(yield_DB$marketable_g, na.rm = TRUE)
qqnorm(yield_DB$marketable_g, main='Normal')
qqline(yield_DB$marketable_g)
shapiro.test(yield_DB$marketable_g)

bc <- boxcox(lm(yield_DB$marketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_DB$bc_marketable <- (yield_DB$marketable_g ^ lambda -1)/lambda

hist(yield_DB$bc_marketable)
skewness(yield_DB$bc_marketable, na.rm = TRUE)
qqnorm(yield_DB$bc_marketable, main='Normal')
qqline(yield_DB$bc_marketable)
shapiro.test(yield_DB$bc_marketable)

```
##### Unmarketable yield
Not sure how to achieve a normal distribution - not even sure I need to, honestly
```{r}
hist(yield_DB$unmarketable_g)
skewness(yield_DB$unmarketable_g, na.rm = TRUE)
qqnorm(yield_DB$unmarketable_g, main='Normal')
qqline(yield_DB$unmarketable_g)
shapiro.test(yield_DB$unmarketable_g)

```

```{r}
bc <- boxcox(lm((yield_DB$unmarketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_DB$bc_unmarketable <- ((yield_DB$unmarketable_g + 1) ^ lambda -1)/lambda

hist(yield_DB$bc_unmarketable)
skewness(yield_DB$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_DB$bc_unmarketable, main='Normal')
qqline(yield_DB$bc_unmarketable)
shapiro.test(yield_DB$bc_unmarketable)

```

##### Total yield
Normal distribution achieved!
```{r}
hist(yield_DB$total_g)
skewness(yield_DB$total_g, na.rm = TRUE)
qqnorm(yield_DB$total_g, main='Normal')
qqline(yield_DB$total_g)
shapiro.test(yield_DB$total_g)

```

```{r}
bc <- boxcox(lm(yield_DB$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_DB$bc_total <- (yield_DB$total_g ^ lambda -1)/lambda

hist(yield_DB$bc_total)
skewness(yield_DB$bc_total, na.rm = TRUE)
qqnorm(yield_DB$bc_total, main='Normal')
qqline(yield_DB$bc_total)
shapiro.test(yield_DB$bc_total)

```

#### Collards

##### Marketable yield
Not sure how to achieve a normal distribution
```{r}
hist(yield_FC$marketable_g)
skewness(yield_FC$marketable_g, na.rm = TRUE)
qqnorm(yield_FC$marketable_g, main='Normal')
qqline(yield_FC$marketable_g)
shapiro.test(yield_FC$marketable_g)

```

```{r}
bc <- boxcox(lm((yield_FC$marketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_FC$bc_marketable <- ((yield_FC$marketable_g + 1) ^ lambda -1)/lambda

hist(yield_FC$bc_marketable)
skewness(yield_FC$bc_marketable, na.rm = TRUE)
qqnorm(yield_FC$bc_marketable, main='Normal')
qqline(yield_FC$bc_marketable)
shapiro.test(yield_FC$bc_marketable)

```
##### Unmarketable yield
Not sure how to achieve a normal distribution
```{r}
hist(yield_FC$unmarketable_g)
skewness(yield_FC$unmarketable_g, na.rm = TRUE)
qqnorm(yield_FC$unmarketable_g, main='Normal')
qqline(yield_FC$unmarketable_g)
shapiro.test(yield_FC$unmarketable_g)

```

```{r}
bc <- boxcox(lm((yield_FC$unmarketable_g + 1) ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_FC$bc_unmarketable <- ((yield_FC$unmarketable_g + 1) ^ lambda -1)/lambda

hist(yield_FC$bc_unmarketable)
skewness(yield_FC$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_FC$bc_unmarketable, main='Normal')
qqline(yield_FC$bc_unmarketable)
shapiro.test(yield_FC$bc_unmarketable)

```

##### Total yield
Closest to a normal distribution, still not quite there
```{r}
hist(yield_FC$total_g)
skewness(yield_FC$total_g, na.rm = TRUE)
qqnorm(yield_FC$total_g, main='Normal')
qqline(yield_FC$total_g)
shapiro.test(yield_FC$total_g)

```

```{r}
bc <- boxcox(lm(yield_FC$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_FC$bc_total <- (yield_FC$total_g ^ lambda -1)/lambda

hist(yield_FC$bc_total)
skewness(yield_FC$bc_total, na.rm = TRUE)
qqnorm(yield_FC$bc_total, main='Normal')
qqline(yield_FC$bc_total)
shapiro.test(yield_FC$bc_total)

```

### Annual yield

#### Strawberries

##### Marketable yield

The original dataset is non-parametric. Boxcox function shows that lambda is between 0 and 0.5, indicating that log, sqrt, or boxcox transformations would be appropriate. Boxcox is the only one that achieves a normal distribution (p = 0.05), just barely.

```{r}
# original dataset
hist(yield_yr_AS$marketable_g)
skewness(yield_yr_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_yr_AS$marketable_g, main='Normal')
qqline(yield_yr_AS$marketable_g)
shapiro.test(yield_yr_AS$marketable_g)

#boxcox transformation
bc <- boxcox(lm(yield_yr_AS$marketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_yr_AS$bc_marketable <- (yield_yr_AS$marketable_g ^ lambda -1)/lambda

hist(yield_yr_AS$bc_marketable)
skewness(yield_yr_AS$bc_marketable, na.rm = TRUE)
qqnorm(yield_yr_AS$bc_marketable, main='Normal')
qqline(yield_yr_AS$bc_marketable)
shapiro.test(yield_yr_AS$bc_marketable)

# log transformation
# yield_yr_AS$log_marketable <- log10(yield_yr_AS$marketable_g)
# shapiro.test(yield_yr_AS$log_marketable)

# sqrt transformation
# yield_yr_AS$sqrt_marketable <- sqrt(yield_yr_AS$marketable_g)
#shapiro.test(yield_yr_AS$sqrt_marketable)

```
2023 only: normal distribution

```{r}
# original dataset
hist(yield_23_AS$marketable_g)
skewness(yield_23_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_23_AS$marketable_g, main='Normal')
qqline(yield_23_AS$marketable_g)
shapiro.test(yield_23_AS$marketable_g)

```
2024 only: normal distribution

```{r}
# original dataset
hist(yield_24_AS$marketable_g)
skewness(yield_24_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_24_AS$marketable_g, main='Normal')
qqline(yield_24_AS$marketable_g)
shapiro.test(yield_24_AS$marketable_g)

```

##### Percent marketable

The original dataset is non-parametric. The lambda is over 2, indicating the boxcox or square transformation will likely be best; I'll also try cubic. However, no transformation strategy successfully achieves a normal distribution; the squared is closest.

```{r}
# original dataset
hist(yield_yr_AS$per_market)
skewness(yield_yr_AS$per_market, na.rm = TRUE)
qqnorm(yield_yr_AS$per_market, main='Normal')
qqline(yield_yr_AS$per_market)
shapiro.test(yield_yr_AS$per_market)

#boxcox transformation
#bc <- boxcox(lm(yield_yr_AS$per_market ~ 1))
#lambda <- bc$x[which.max(bc$y)]
#yield_yr_AS$bc_per <- (yield_yr_AS$per_market ^ lambda -1)/lambda
#shapiro.test(yield_yr_AS$bc_per)

# squared transformation
# yield_yr_AS$sq_marketable <- (yield_yr_AS$marketable_g)^2
# shapiro.test(yield_yr_AS$sq_marketable)

# cubic transformation
# yield_yr_AS$cube_marketable <- (yield_yr_AS$marketable_g)^3
# shapiro.test(yield_yr_AS$cube_marketable)

```
2023 only: normal distribution

```{r}
# original dataset

hist(yield_23_AS$per_market)
skewness(yield_23_AS$per_market, na.rm = TRUE)
qqnorm(yield_23_AS$per_market, main='Normal')
qqline(yield_23_AS$per_market)
shapiro.test(yield_23_AS$per_market)

```
2024 only: The original dataset is non-parametric. The lambda is about 2, indiciating that boxcox or squared or cubic will be the best transformation strategy. None achieve a normal distribution, but the cubic is best (p = 0.03). Boxcox isn't far behind, for consistency (p = 0.02). BUT, I tried an ANOVA with the cubic transformation, and model assumptions were not met

```{r}
# original dataset
hist(yield_24_AS$per_market)
skewness(yield_24_AS$per_market, na.rm = TRUE)
qqnorm(yield_24_AS$per_market, main='Normal')
qqline(yield_24_AS$per_market)
shapiro.test(yield_24_AS$per_market)

#boxcox transformation
# bc <- boxcox(lm(yield_24_AS$per_market ~ 1))
# lambda <- bc$x[which.max(bc$y)]
# yield_24_AS$bc_per <- (yield_24_AS$per_market ^ lambda -1)/lambda
# shapiro.test(yield_24_AS$bc_per)

#squared
# yield_24_AS$sq_per <- (yield_24_AS$per_market)^2
# shapiro.test(yield_24_AS$sq_per)

#cubic
# yield_24_AS$cubic_per <- (yield_24_AS$per_market)^3
# shapiro.test(yield_24_AS$cubic_per)
```

##### Unmarketable yield

The original dataset is not normally distributed. Lambda is close to 0, indicating that box cox or log would be best transformations. Both have a similar quality and achieve a normal distribution
```{r}
#original dataset
hist(yield_yr_AS$unmarketable_g)
skewness(yield_yr_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_yr_AS$unmarketable_g, main='Normal')
qqline(yield_yr_AS$unmarketable_g)
shapiro.test(yield_yr_AS$unmarketable_g)

#boxcox
bc <- boxcox(lm(yield_yr_AS$unmarketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_yr_AS$bc_unmarketable <- (yield_yr_AS$unmarketable_g ^ lambda -1)/lambda

hist(yield_yr_AS$bc_unmarketable)
skewness(yield_yr_AS$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_yr_AS$bc_unmarketable, main='Normal')
qqline(yield_yr_AS$bc_unmarketable)
shapiro.test(yield_yr_AS$bc_unmarketable)

#log
#yield_yr_AS$log_market <- log10(yield_yr_AS$unmarketable_g)
#shapiro.test(yield_yr_AS$log_market)

```

2023 only: normal distribution

```{r}
# original dataset
hist(yield_23_AS$unmarketable_g)
skewness(yield_23_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_23_AS$unmarketable_g, main='Normal')
qqline(yield_23_AS$unmarketable_g)
shapiro.test(yield_23_AS$unmarketable_g)

```
2024 only: Original dataset isn't quite normally distributed (p = 0.04). Lambda is close to 0, indicating that log or inverse square root would be best. Because I don't think I'm going to actually analyze this dataset, I just did boxcox, which achieved a normal distribution

```{r}
# original dataset
hist(yield_24_AS$unmarketable_g)
skewness(yield_24_AS$unmarketable_g, na.rm = TRUE)
qqnorm(yield_24_AS$unmarketable_g, main='Normal')
qqline(yield_24_AS$unmarketable_g)
shapiro.test(yield_24_AS$unmarketable_g)

# boxcox
bc <- boxcox(lm(yield_24_AS$unmarketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_24_AS$bc_unmarket <- (yield_24_AS$unmarketable_g ^ lambda -1)/lambda

hist(yield_24_AS$bc_unmarket)
skewness(yield_24_AS$bc_unmarket, na.rm = TRUE)
qqnorm(yield_24_AS$bc_unmarket, main='Normal')
qqline(yield_24_AS$bc_unmarket)
shapiro.test(yield_24_AS$bc_unmarket)
```

##### Total yield

The original dataset is non-parametric. Boxcox function found that the lambda is close to 0, indicating that a log or boxcox transformation would be most appropriate. However, neither achieves a normal distribution (p = 0.01 for both)
```{r}
#original data set
hist(yield_yr_AS$total_g)
skewness(yield_yr_AS$total_g, na.rm = TRUE)
qqnorm(yield_yr_AS$total_g, main='Normal')
qqline(yield_yr_AS$total_g)
shapiro.test(yield_yr_AS$total_g)

# boxcox
#bc <- boxcox(lm(yield_yr_AS$total_g ~ 1))
#lambda <- bc$x[which.max(bc$y)]
#yield_yr_AS$bc_total <- (yield_yr_AS$total_g ^ lambda -1)/lambda
#shapiro.test(yield_yr_AS$bc_total)

# log
#yield_yr_AS$log_total <- log10(yield_yr_AS$total_g)
#shapiro.test(yield_yr_AS$log_total)

```
2023 only: normal distribution

```{r}
# original dataset
hist(yield_23_AS$total_g)
skewness(yield_23_AS$total_g, na.rm = TRUE)
qqnorm(yield_23_AS$total_g, main='Normal')
qqline(yield_23_AS$total_g)
shapiro.test(yield_23_AS$total_g)

```
2024 only: normal distribution

```{r}
# original dataset

hist(yield_24_AS$total_g)
skewness(yield_24_AS$total_g, na.rm = TRUE)
qqnorm(yield_24_AS$total_g, main='Normal')
qqline(yield_24_AS$total_g)
shapiro.test(yield_24_AS$total_g)

```

#### Beans

##### Marketable yield

Original dataset is non-parametric. Lambda is close to 0, indicating log or boxcox, but neither achieves a normal distribution
```{r}
hist(yield_yr_DB$marketable_g)
skewness(yield_yr_DB$marketable_g, na.rm = TRUE)
qqnorm(yield_yr_DB$marketable_g, main='Normal')
qqline(yield_yr_DB$marketable_g)
shapiro.test(yield_yr_DB$marketable_g)

#boxcox
#bc <- boxcox(lm(yield_yr_DB$marketable_g ~ 1))
#lambda <- bc$x[which.max(bc$y)]
#yield_yr_DB$bc_marketable <- (yield_yr_DB$marketable_g ^ lambda -1)/lambda
#shapiro.test(yield_yr_DB$bc_marketable)

#log
#yield_yr_DB$log_marketable <- log10(yield_yr_DB$marketable_g)
#shapiro.test(yield_yr_DB$log_marketable)

```

2023 only: normal distribution

```{r}
# original dataset
hist(yield_23_DB$marketable_g)
skewness(yield_23_DB$marketable_g, na.rm = TRUE)
qqnorm(yield_23_DB$marketable_g, main='Normal')
qqline(yield_23_DB$marketable_g)
shapiro.test(yield_23_DB$marketable_g)

```

2024 only: The dataset is non-parametric. Lambda indicates that either a boxcox, inverse, or inverse sqrt would be best. All work, but boxcox is best
```{r}
# original dataset
hist(yield_24_DB$marketable_g)
skewness(yield_24_DB$marketable_g, na.rm = TRUE)
qqnorm(yield_24_DB$marketable_g, main='Normal')
qqline(yield_24_DB$marketable_g)
shapiro.test(yield_24_DB$marketable_g)

#boxcox transformation
bc <- boxcox(lm(yield_24_DB$marketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_24_DB$bc_marketable <- (yield_24_DB$marketable_g ^ lambda -1)/lambda

hist(yield_24_DB$bc_marketable)
skewness(yield_24_DB$bc_marketable, na.rm = TRUE)
qqnorm(yield_24_DB$bc_marketable, main='Normal')
qqline(yield_24_DB$bc_marketable)
shapiro.test(yield_24_DB$bc_marketable)

#inverse
#yield_24_DB$inverse_marketable <- 1/yield_24_DB$marketable_g
#shapiro.test(yield_24_DB$inverse_marketable)

#inverse sqrt
#yield_24_DB$sqrt_in_marketable <- 1/sqrt(yield_24_DB$marketable_g)
#shapiro.test(yield_24_DB$sqrt_in_marketable)
```

##### Percent marketable
Original dataset is non-parametric. Lambda is off the charts, and there is no transformation that is going to fix this lol
```{r}
hist(yield_yr_DB$per_market)
skewness(yield_yr_DB$per_market, na.rm = TRUE)
qqnorm(yield_yr_DB$per_market, main='Normal')
qqline(yield_yr_DB$per_market)
shapiro.test(yield_yr_DB$per_market)

#boxcox
#bc <- boxcox(lm(yield_yr_DB$per_market ~ 1))
#lambda <- bc$x[which.max(bc$y)]
#yield_yr_DB$bc_per <- (yield_yr_DB$per_market ^ lambda -1)/lambda
#shapiro.test(yield_yr_DB$bc_per)

```

2023 only: everything is 100%, so there is no distribution.

```{r}
# original dataset
hist(yield_23_DB$per_market)
skewness(yield_23_DB$per_market, na.rm = TRUE)
qqnorm(yield_23_DB$per_market, main='Normal')
qqline(yield_23_DB$per_market)

```
2024 only: the lambda is off the charts, so this one will also stay non-parametric
```{r}
# original dataset
hist(yield_24_DB$per_market)
skewness(yield_24_DB$per_market, na.rm = TRUE)
qqnorm(yield_24_DB$per_market, main='Normal')
qqline(yield_24_DB$per_market)
shapiro.test(yield_24_DB$per_market)
bc <- boxcox(lm(yield_24_DB$per_market ~ 1))
```

##### Unmarketable yield
There is no way to make this a normal distribution.
```{r}
hist(yield_yr_DB$unmarketable_g)
skewness(yield_yr_DB$unmarketable_g, na.rm = TRUE)
qqnorm(yield_yr_DB$unmarketable_g, main='Normal')
qqline(yield_yr_DB$unmarketable_g)
shapiro.test(yield_yr_DB$unmarketable_g)
bc <- boxcox(lm((yield_yr_DB$unmarketable_g + 1) ~ 1))
```

2023 only: non-parametric
```{r}
hist(yield_23_DB$unmarketable_g)
skewness(yield_23_DB$unmarketable_g, na.rm = TRUE)
qqnorm(yield_23_DB$unmarketable_g, main='Normal')
qqline(yield_23_DB$unmarketable_g)

```

2024 only: non-parametric
```{r}

hist(yield_24_DB$unmarketable_g)
skewness(yield_24_DB$unmarketable_g, na.rm = TRUE)
qqnorm(yield_24_DB$unmarketable_g, main='Normal')
qqline(yield_24_DB$unmarketable_g)
shapiro.test(yield_24_DB$unmarketable_g)
bc <- boxcox(lm((yield_24_DB$unmarketable_g + 1) ~ 1))

```

##### Total yield

The original dataset is non-parametric. Lambda indicates that boxcox or log transformation are best suited. Neither, however, results in a normal distribution
```{r}
hist(yield_yr_DB$total_g)
skewness(yield_yr_DB$total_g, na.rm = TRUE)
qqnorm(yield_yr_DB$total_g, main='Normal')
qqline(yield_yr_DB$total_g)
shapiro.test(yield_yr_DB$total_g)

#boxcox
#bc <- boxcox(lm(yield_yr_DB$total_g ~ 1))
#lambda <- bc$x[which.max(bc$y)]
#yield_yr_DB$bc_total <- (yield_yr_DB$total_g ^ lambda -1)/lambda
#shapiro.test(yield_yr_DB$bc_total)

#log
#yield_yr_DB$log_total <- log10(yield_yr_DB$total_g)
#shapiro.test(yield_yr_DB$log_total)

```

2023 only: normal distribution

```{r}
hist(yield_23_DB$total_g)
skewness(yield_23_DB$total_g, na.rm = TRUE)
qqnorm(yield_23_DB$total_g, main='Normal')
qqline(yield_23_DB$total_g)
shapiro.test(yield_23_DB$total_g)

```

2024 only: The original dataset is non-parametric. The lambda indicates a boxcox, inverse, or inverse sqrt would be most appropriate. All are successful, but the boxcox is the best

```{r}
hist(yield_24_DB$total_g)
skewness(yield_24_DB$total_g, na.rm = TRUE)
qqnorm(yield_24_DB$total_g, main='Normal')
qqline(yield_24_DB$total_g)
shapiro.test(yield_24_DB$total_g)

#boxcox
bc <- boxcox(lm(yield_24_DB$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_24_DB$bc_total <- (yield_24_DB$total_g ^ lambda -1)/lambda

hist(yield_24_DB$bc_total)
skewness(yield_24_DB$bc_total, na.rm = TRUE)
qqnorm(yield_24_DB$bc_total, main='Normal')
qqline(yield_24_DB$bc_total)
shapiro.test(yield_24_DB$bc_total)

#inverse
#yield_24_DB$inverse_total <- 1/yield_24_DB$total_g
#shapiro.test(yield_24_DB$inverse_total)

#inverse sqrt
#yield_24_DB$inverse_sqrt_total <- 1/sqrt(yield_24_DB$total_g)
#shapiro.test(yield_24_DB$inverse_sqrt_total)

```

#### Collards

##### Marketable yield

The original dataset is normally distributed
```{r}
# original dataset
hist(yield_yr_FC$marketable_g)
skewness(yield_yr_FC$marketable_g, na.rm = TRUE)
qqnorm(yield_yr_FC$marketable_g, main='Normal')
qqline(yield_yr_FC$marketable_g)
shapiro.test(yield_yr_FC$marketable_g)

```

2023 only: The original dataset is non-parametric. The lambda is about 1.5, indicating that a boxcox, square, or cubic transformation would be best. Cubic offers the best distribution (p = 0.9)

```{r}
# original dataset
hist(yield_23_FC$marketable_g)
skewness(yield_23_FC$marketable_g, na.rm = TRUE)
qqnorm(yield_23_FC$marketable_g, main='Normal')
qqline(yield_23_FC$marketable_g)
shapiro.test(yield_23_FC$marketable_g)

#boxcox
bc <- boxcox(lm(yield_23_FC$marketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_23_FC$bc_market <- (yield_23_FC$marketable_g ^ lambda -1)/lambda

hist(yield_23_FC$bc_market)
skewness(yield_23_FC$bc_market, na.rm = TRUE)
qqnorm(yield_23_FC$bc_market, main='Normal')
qqline(yield_23_FC$bc_market)
shapiro.test(yield_23_FC$bc_market)

#squared
yield_23_FC$sq_market <- yield_23_FC$marketable_g^2

hist(yield_23_FC$sq_market)
skewness(yield_23_FC$sq_market, na.rm = TRUE)
qqnorm(yield_23_FC$sq_market, main='Normal')
qqline(yield_23_FC$sq_market)
shapiro.test(yield_23_FC$sq_market)

#cubic
yield_23_FC$cubic_market <- yield_23_FC$marketable_g^3

hist(yield_23_FC$cubic_market)
skewness(yield_23_FC$cubic_market, na.rm = TRUE)
qqnorm(yield_23_FC$cubic_market, main='Normal')
qqline(yield_23_FC$cubic_market)
shapiro.test(yield_23_FC$cubic_market)


```
2024 only: normal distribution

```{r}
# original dataset
hist(yield_24_AS$marketable_g)
skewness(yield_24_AS$marketable_g, na.rm = TRUE)
qqnorm(yield_24_AS$marketable_g, main='Normal')
qqline(yield_24_AS$marketable_g)
shapiro.test(yield_24_AS$marketable_g)

```

##### Percent marketable

The original dataset is normally distributed
```{r}
# original dataset
hist(yield_yr_FC$per_market)
skewness(yield_yr_FC$per_market, na.rm = TRUE)
qqnorm(yield_yr_FC$per_market, main='Normal')
qqline(yield_yr_FC$per_market)
shapiro.test(yield_yr_FC$per_market)

```
2023 only: normal distribution

```{r}
# original dataset

hist(yield_23_FC$per_market)
skewness(yield_23_FC$per_market, na.rm = TRUE)
qqnorm(yield_23_FC$per_market, main='Normal')
qqline(yield_23_FC$per_market)
shapiro.test(yield_23_FC$per_market)

```
2024 only: Normal distribution (p = 0.09), though a boxcox transformation improves it

```{r}
# original dataset
hist(yield_24_FC$per_market)
skewness(yield_24_FC$per_market, na.rm = TRUE)
qqnorm(yield_24_FC$per_market, main='Normal')
qqline(yield_24_FC$per_market)
shapiro.test(yield_24_FC$per_market)

#boxcox transformation
bc <- boxcox(lm(yield_24_FC$per_market ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_24_FC$bc_per <- (yield_24_FC$per_market ^ lambda -1)/lambda

hist(yield_24_FC$bc_per)
skewness(yield_24_FC$bc_per, na.rm = TRUE)
qqnorm(yield_24_FC$bc_per, main='Normal')
qqline(yield_24_FC$bc_per)
shapiro.test(yield_24_FC$bc_per)

#log
yield_24_FC$log_per <- log10(yield_24_FC$per_market)

hist(yield_24_FC$log_per)
skewness(yield_24_FC$log_per, na.rm = TRUE)
qqnorm(yield_24_FC$log_per, main='Normal')
qqline(yield_24_FC$log_per)
shapiro.test(yield_24_FC$log_per)

```

##### Unmarketable yield

The original dataset is non-parametric. A boxcox or log transformation achieves a normal distribution and have similar p-values.
```{r}
#original dataset
hist(yield_yr_FC$unmarketable_g)
skewness(yield_yr_FC$unmarketable_g, na.rm = TRUE)
qqnorm(yield_yr_FC$unmarketable_g, main='Normal')
qqline(yield_yr_FC$unmarketable_g)
shapiro.test(yield_yr_FC$unmarketable_g)

#boxcox
bc <- boxcox(lm(yield_yr_FC$unmarketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_yr_FC$bc_unmarketable <- (yield_yr_FC$unmarketable_g ^ lambda -1)/lambda

hist(yield_yr_FC$bc_unmarketable)
skewness(yield_yr_FC$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_yr_FC$bc_unmarketable, main='Normal')
qqline(yield_yr_FC$bc_unmarketable)
shapiro.test(yield_yr_FC$bc_unmarketable)

#sqrt
yield_yr_FC$log_market <- sqrt(yield_yr_FC$unmarketable_g)

hist(yield_yr_FC$log_market)
skewness(yield_yr_FC$log_market, na.rm = TRUE)
qqnorm(yield_yr_FC$log_market, main='Normal')
qqline(yield_yr_FC$log_market)
shapiro.test(yield_yr_FC$log_market)

```

2023 only: The original dataset is non-parametric. Lambda indicates a boxcox or square transformation will be best, and I'll try a cubic -- which is the one that ultimately achieved the normal distribution.

```{r}
# original dataset
hist(yield_23_FC$unmarketable_g)
skewness(yield_23_FC$unmarketable_g, na.rm = TRUE)
qqnorm(yield_23_FC$unmarketable_g, main='Normal')
qqline(yield_23_FC$unmarketable_g)
shapiro.test(yield_23_FC$unmarketable_g)

#boxcox
bc <- boxcox(lm(yield_23_FC$unmarketable_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_23_FC$bc_unmarketable <- (yield_23_FC$unmarketable_g ^ lambda -1)/lambda

hist(yield_23_FC$bc_unmarketable)
skewness(yield_23_FC$bc_unmarketable, na.rm = TRUE)
qqnorm(yield_23_FC$bc_unmarketable, main='Normal')
qqline(yield_23_FC$bc_unmarketable)
shapiro.test(yield_23_FC$bc_unmarketable)

#squared 
yield_23_FC$sq_unmarketable <- yield_23_FC$unmarketable_g^2

hist(yield_23_FC$sq_unmarketable)
skewness(yield_23_FC$sq_unmarketable, na.rm = TRUE)
qqnorm(yield_23_FC$sq_unmarketable, main='Normal')
qqline(yield_23_FC$sq_unmarketable)
shapiro.test(yield_23_FC$sq_unmarketable)

#cubic 
yield_23_FC$cubic_unmarketable <- yield_23_FC$unmarketable_g^3

hist(yield_23_FC$cubic_unmarketable)
skewness(yield_23_FC$cubic_unmarketable, na.rm = TRUE)
qqnorm(yield_23_FC$cubic_unmarketable, main='Normal')
qqline(yield_23_FC$cubic_unmarketable)
shapiro.test(yield_23_FC$cubic_unmarketable)

```

2024 only: normal distribution

```{r}
# original dataset
hist(yield_24_FC$unmarketable_g)
skewness(yield_24_FC$unmarketable_g, na.rm = TRUE)
qqnorm(yield_24_FC$unmarketable_g, main='Normal')
qqline(yield_24_FC$unmarketable_g)
shapiro.test(yield_24_FC$unmarketable_g)

```

##### Total yield

The original dataset is normally distributed
```{r}
#original data set
hist(yield_yr_FC$total_g)
skewness(yield_yr_FC$total_g, na.rm = TRUE)
qqnorm(yield_yr_FC$total_g, main='Normal')
qqline(yield_yr_FC$total_g)
shapiro.test(yield_yr_FC$total_g)

```
2023 only: The original dataset is non-parametric. Lambda indicates that squared or cubic transformation will be best. Cubic is the only one that results in a normal distribution

```{r}
# original dataset
hist(yield_23_FC$total_g)
skewness(yield_23_FC$total_g, na.rm = TRUE)
qqnorm(yield_23_FC$total_g, main='Normal')
qqline(yield_23_FC$total_g)
shapiro.test(yield_23_FC$total_g)

#boxcox
bc <- boxcox(lm(yield_23_FC$total_g ~ 1))
lambda <- bc$x[which.max(bc$y)]
yield_23_FC$bc_total <- (yield_23_FC$total_g ^ lambda -1)/lambda

hist(yield_23_FC$bc_total)
skewness(yield_23_FC$bc_total, na.rm = TRUE)
qqnorm(yield_23_FC$bc_total, main='Normal')
qqline(yield_23_FC$bc_total)
shapiro.test(yield_23_FC$bc_total)

#squared 
yield_23_FC$sq_total <- yield_23_FC$total_g^2

hist(yield_23_FC$sq_total)
skewness(yield_23_FC$sq_total, na.rm = TRUE)
qqnorm(yield_23_FC$sq_total, main='Normal')
qqline(yield_23_FC$sq_total)
shapiro.test(yield_23_FC$sq_total)

#cubic 
yield_23_FC$cubic_total <- yield_23_FC$total_g^3

hist(yield_23_FC$cubic_total)
skewness(yield_23_FC$cubic_total, na.rm = TRUE)
qqnorm(yield_23_FC$cubic_total, main='Normal')
qqline(yield_23_FC$cubic_total)
shapiro.test(yield_23_FC$cubic_total)

```
2024 only: normal distribution

```{r}
# original dataset

hist(yield_24_AS$total_g)
skewness(yield_24_AS$total_g, na.rm = TRUE)
qqnorm(yield_24_AS$total_g, main='Normal')
qqline(yield_24_AS$total_g)
shapiro.test(yield_24_AS$total_g)

```

### SPAD
At what point do we mark values as NA because the SPAD just can't go that high? We didn't have an answer for this because it doesn't seem like any of our measurements were "too high" for the meter. saying that, I'm suspicious of the measurements over 66.  Regardless, it doesn't make sense to check for normality for the whole data set, when I literally have to separate by crop for analysis, so doing that


#### Strawberries

##### outliers removed

The original dataset is non-parametric. Lambda is between 0.5 and 1, indicating that a sqrt or boxcox transformation would be best suited, but neither results in a normal distribution
```{r}
#original dataset
hist(spad_AS$value)
skewness(spad_AS$value, na.rm = TRUE)
qqnorm(spad_AS$value, main='Normal')
qqline(spad_AS$value)
shapiro.test(spad_AS$value)

#boxcox
bc <- boxcox(lm(spad_AS$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_AS$bc_value <- (spad_AS$value ^ lambda -1)/lambda

hist(spad_AS$bc_value)
skewness(spad_AS$bc_value, na.rm = TRUE)
qqnorm(spad_AS$bc_value, main='Normal')
qqline(spad_AS$bc_value)
shapiro.test(spad_AS$bc_value)

# sqrt
spad_AS$sqrt_value <- sqrt(spad_AS$value)

hist(spad_AS$sqrt_value)
skewness(spad_AS$sqrt_value, na.rm = TRUE)
qqnorm(spad_AS$sqrt_value, main='Normal')
qqline(spad_AS$sqrt_value)
shapiro.test(spad_AS$sqrt_value)
```

2023 only: The dataset is non-parametric. Lambda is between 0 and 0.5, indicating a log, sqrt, or boxcox transformation would be most appropriate. All are successful, but boxcox is the most normal distribution
```{r}
spad_23_AS <- subset(spad_AS, year == "2023")

#original dataset
hist(spad_23_AS$value)
skewness(spad_23_AS$value, na.rm = TRUE)
qqnorm(spad_23_AS$value, main='Normal')
qqline(spad_23_AS$value)
shapiro.test(spad_23_AS$value)

#boxcox
bc <- boxcox(lm(spad_23_AS$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_AS$bc_value <- (spad_23_AS$value ^ lambda -1)/lambda

hist(spad_23_AS$bc_value)
skewness(spad_23_AS$bc_value, na.rm = TRUE)
qqnorm(spad_23_AS$bc_value, main='Normal')
qqline(spad_23_AS$bc_value)
shapiro.test(spad_23_AS$bc_value)

# log
spad_23_AS$log_value <- log10(spad_23_AS$value)

hist(spad_23_AS$log_value)
skewness(spad_23_AS$log_value, na.rm = TRUE)
qqnorm(spad_23_AS$log_value, main='Normal')
qqline(spad_23_AS$log_value)
shapiro.test(spad_23_AS$log_value)


# sqrt
spad_23_AS$sqrt_value <- sqrt(spad_23_AS$value)

hist(spad_23_AS$sqrt_value)
skewness(spad_23_AS$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_AS$sqrt_value, main='Normal')
qqline(spad_23_AS$sqrt_value)
shapiro.test(spad_23_AS$sqrt_value)
```

2024 only: The dataset is non-parametric with a lambda between 1 and 2, indicating a boxcox or square transformation would be most appropriate. Neither are successful, though
```{r}
spad_24_AS <- subset(spad_AS, year == "2024")

#original dataset
hist(spad_24_AS$value)
skewness(spad_24_AS$value, na.rm = TRUE)
qqnorm(spad_24_AS$value, main='Normal')
qqline(spad_24_AS$value)
shapiro.test(spad_24_AS$value)

#boxcox
bc <- boxcox(lm(spad_24_AS$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_24_AS$bc_value <- (spad_24_AS$value ^ lambda -1)/lambda

hist(spad_24_AS$bc_value)
skewness(spad_24_AS$bc_value, na.rm = TRUE)
qqnorm(spad_24_AS$bc_value, main='Normal')
qqline(spad_24_AS$bc_value)
shapiro.test(spad_24_AS$bc_value)

# squared
spad_24_AS$sq_value <- spad_24_AS$value^2

hist(spad_24_AS$sq_value)
skewness(spad_24_AS$sq_value, na.rm = TRUE)
qqnorm(spad_24_AS$sq_value, main='Normal')
qqline(spad_24_AS$sq_value)
shapiro.test(spad_24_AS$sq_value)

```


##### including outliers

The dataset is non-parametric, with a lambda close to -0.5, indicating an inverse square root, log, or boxcox will be most appropriate. None achieve a normal distribution
```{r}
#original dataset
hist(spad_AS_out$value)
skewness(spad_AS_out$value, na.rm = TRUE)
qqnorm(spad_AS_out$value, main='Normal')
qqline(spad_AS_out$value)
shapiro.test(spad_AS_out$value)

#boxcox
bc <- boxcox(lm(spad_AS_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_AS_out$bc_value <- (spad_AS_out$value ^ lambda -1)/lambda

hist(spad_AS_out$bc_value)
skewness(spad_AS_out$bc_value, na.rm = TRUE)
qqnorm(spad_AS_out$bc_value, main='Normal')
qqline(spad_AS_out$bc_value)
shapiro.test(spad_AS_out$bc_value)

# log
spad_AS_out$log_value <- log10(spad_AS_out$value)

hist(spad_AS_out$log_value)
skewness(spad_AS_out$log_value, na.rm = TRUE)
qqnorm(spad_AS_out$log_value, main='Normal')
qqline(spad_AS_out$log_value)
shapiro.test(spad_AS_out$log_value) 

# inverse sqrt
spad_AS_out$in_sqrt_value <- 1/sqrt(spad_AS_out$value)

hist(spad_AS_out$in_sqrt_value)
skewness(spad_AS_out$in_sqrt_value, na.rm = TRUE)
qqnorm(spad_AS_out$in_sqrt_value, main='Normal')
qqline(spad_AS_out$in_sqrt_value)
shapiro.test(spad_AS_out$in_sqrt_value)
```

2023 only: The dataset is non-parametric. Lambda is between 0 and 0.5, indicating a log, sqrt, or boxcox transformation would be most appropriate. All are successful, but boxcox is the most normal distribution
```{r}
spad_23_AS_out <- subset(spad_AS_out, year == "2023")

#original dataset
hist(spad_23_AS_out$value)
skewness(spad_23_AS_out$value, na.rm = TRUE)
qqnorm(spad_23_AS_out$value, main='Normal')
qqline(spad_23_AS_out$value)
shapiro.test(spad_23_AS_out$value)

#boxcox
bc <- boxcox(lm(spad_23_AS_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_AS_out$bc_value <- (spad_23_AS_out$value ^ lambda -1)/lambda

hist(spad_23_AS_out$bc_value)
skewness(spad_23_AS_out$bc_value, na.rm = TRUE)
qqnorm(spad_23_AS_out$bc_value, main='Normal')
qqline(spad_23_AS_out$bc_value)
shapiro.test(spad_23_AS_out$bc_value)

# log
spad_23_AS_out$log_value <- log10(spad_23_AS_out$value)

hist(spad_23_AS_out$log_value)
skewness(spad_23_AS_out$log_value, na.rm = TRUE)
qqnorm(spad_23_AS_out$log_value, main='Normal')
qqline(spad_23_AS_out$log_value)
shapiro.test(spad_23_AS_out$log_value)

# sqrt
spad_23_AS_out$sqrt_value <- sqrt(spad_23_AS_out$value)

hist(spad_23_AS_out$sqrt_value)
skewness(spad_23_AS_out$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_AS_out$sqrt_value, main='Normal')
qqline(spad_23_AS_out$sqrt_value)
shapiro.test(spad_23_AS_out$sqrt_value)
```

2024 only: The dataset is non-parametric with a lambda between 0 and -0.5, indicating a boxcox, log, or inverse sqrt transformation would be most appropriate. None are successful, though
```{r}
spad_24_AS_out <- subset(spad_AS_out, year == "2024")

#original dataset
hist(spad_24_AS_out$value)
skewness(spad_24_AS_out$value, na.rm = TRUE)
qqnorm(spad_24_AS_out$value, main='Normal')
qqline(spad_24_AS_out$value)
shapiro.test(spad_24_AS_out$value)

#boxcox
bc <- boxcox(lm(spad_24_AS_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_24_AS_out$bc_value <- (spad_24_AS_out$value ^ lambda -1)/lambda

hist(spad_24_AS_out$bc_value)
skewness(spad_24_AS_out$bc_value, na.rm = TRUE)
qqnorm(spad_24_AS_out$bc_value, main='Normal')
qqline(spad_24_AS_out$bc_value)
shapiro.test(spad_24_AS_out$bc_value)

# log
spad_24_AS_out$log_value <- log10(spad_24_AS_out$value)

hist(spad_24_AS_out$log_value)
skewness(spad_24_AS_out$log_value, na.rm = TRUE)
qqnorm(spad_24_AS_out$log_value, main='Normal')
qqline(spad_24_AS_out$log_value)
shapiro.test(spad_24_AS_out$log_value)

# inverse square root
spad_24_AS_out$in_sqrt_value <- 1/sqrt(spad_24_AS_out$value)

hist(spad_24_AS_out$in_sqrt_value)
skewness(spad_24_AS_out$in_sqrt_value, na.rm = TRUE)
qqnorm(spad_24_AS_out$in_sqrt_value, main='Normal')
qqline(spad_24_AS_out$in_sqrt_value)
shapiro.test(spad_24_AS_out$in_sqrt_value)

```


#### Beans

##### outliers removed

The original dataset is non-parametric. Lambda is close to 1, indicating that a square root or boxcox transformation might work, but neither results in a normal distribution
```{r}
#original dataset
hist(spad_DB$value)
skewness(spad_DB$value, na.rm = TRUE)
qqnorm(spad_DB$value, main='Normal')
qqline(spad_DB$value)
shapiro.test(spad_DB$value)

#boxcox
bc <- boxcox(lm(spad_DB$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_DB$bc_value <- (spad_DB$value ^ lambda -1)/lambda

hist(spad_DB$bc_value)
skewness(spad_DB$bc_value, na.rm = TRUE)
qqnorm(spad_DB$bc_value, main='Normal')
qqline(spad_DB$bc_value)
shapiro.test(spad_DB$bc_value)

# sqrt
spad_DB$sqrt_value <- sqrt(spad_DB$value)

hist(spad_DB$sqrt_value)
skewness(spad_DB$sqrt_value, na.rm = TRUE)
qqnorm(spad_DB$sqrt_value, main='Normal')
qqline(spad_DB$sqrt_value)
shapiro.test(spad_DB$sqrt_value)

```

2023 only: The dataset is non-parametric. Lambda is between 0 and -0.5, indicating a log, sqrt, or boxcox transformation would be most appropriate. None result in a normal distribution, though
```{r}
spad_23_DB <- subset(spad_DB, year == "2023")

#original dataset
hist(spad_23_DB$value)
skewness(spad_23_DB$value, na.rm = TRUE)
qqnorm(spad_23_DB$value, main='Normal')
qqline(spad_23_DB$value)
shapiro.test(spad_23_DB$value)

#boxcox
bc <- boxcox(lm(spad_23_DB$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_DB$bc_value <- (spad_23_DB$value ^ lambda -1)/lambda

hist(spad_23_DB$bc_value)
skewness(spad_23_DB$bc_value, na.rm = TRUE)
qqnorm(spad_23_DB$bc_value, main='Normal')
qqline(spad_23_DB$bc_value)
shapiro.test(spad_23_DB$bc_value)

# log
spad_23_DB$log_value <- log10(spad_23_DB$value)

hist(spad_23_DB$log_value)
skewness(spad_23_DB$log_value, na.rm = TRUE)
qqnorm(spad_23_DB$log_value, main='Normal')
qqline(spad_23_DB$log_value)
shapiro.test(spad_23_DB$log_value)


# inverse sqrt
spad_23_DB$sqrt_value <- 1/sqrt(spad_23_DB$value)

hist(spad_23_DB$sqrt_value)
skewness(spad_23_DB$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_DB$sqrt_value, main='Normal')
qqline(spad_23_DB$sqrt_value)
shapiro.test(spad_23_DB$sqrt_value)
```

2024 only: The dataset is non-parametric with a lambda between 1 and 2, indicating a boxcox or square transformation would be most appropriate. Neither are successful, though
```{r}
spad_24_DB <- subset(spad_DB, year == "2024")

#original dataset
hist(spad_24_DB$value)
skewness(spad_24_DB$value, na.rm = TRUE)
qqnorm(spad_24_DB$value, main='Normal')
qqline(spad_24_DB$value)
shapiro.test(spad_24_DB$value)

#boxcox
bc <- boxcox(lm(spad_24_DB$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_24_DB$bc_value <- (spad_24_DB$value ^ lambda -1)/lambda

hist(spad_24_DB$bc_value)
skewness(spad_24_DB$bc_value, na.rm = TRUE)
qqnorm(spad_24_DB$bc_value, main='Normal')
qqline(spad_24_DB$bc_value)
shapiro.test(spad_24_DB$bc_value)

# squared
spad_24_DB$sq_value <- spad_24_DB$value^2

hist(spad_24_DB$sq_value)
skewness(spad_24_DB$sq_value, na.rm = TRUE)
qqnorm(spad_24_DB$sq_value, main='Normal')
qqline(spad_24_DB$sq_value)
shapiro.test(spad_24_DB$sq_value)

```


##### including outliers

The dataset is non-parametric, with a lambda close between 1 and 2, indicating an squared or boxcox will be most appropriate. Neither achieve a normal distribution
```{r}
#original dataset
hist(spad_DB_out$value)
skewness(spad_DB_out$value, na.rm = TRUE)
qqnorm(spad_DB_out$value, main='Normal')
qqline(spad_DB_out$value)
shapiro.test(spad_DB_out$value)

#boxcox
bc <- boxcox(lm(spad_DB_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_DB_out$bc_value <- (spad_DB_out$value ^ lambda -1)/lambda

hist(spad_DB_out$bc_value)
skewness(spad_DB_out$bc_value, na.rm = TRUE)
qqnorm(spad_DB_out$bc_value, main='Normal')
qqline(spad_DB_out$bc_value)
shapiro.test(spad_DB_out$bc_value)

# squared
spad_DB_out$sq_value <- spad_DB_out$value^2

hist(spad_DB_out$sq_value)
skewness(spad_DB_out$sq_value, na.rm = TRUE)
qqnorm(spad_DB_out$sq_value, main='Normal')
qqline(spad_DB_out$sq_value)
shapiro.test(spad_DB_out$sq_value) 

```

2023 only: The dataset is non-parametric. Lambda is between 0.5 and 1, indicating a sqrt or boxcox transformation would be most appropriate. Neither results in a normal distribution though
```{r}
spad_23_DB_out <- subset(spad_DB_out, year == "2023")

#original dataset
hist(spad_23_DB_out$value)
skewness(spad_23_DB_out$value, na.rm = TRUE)
qqnorm(spad_23_DB_out$value, main='Normal')
qqline(spad_23_DB_out$value)
shapiro.test(spad_23_DB_out$value)

#boxcox
bc <- boxcox(lm(spad_23_DB_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_DB_out$bc_value <- (spad_23_DB_out$value ^ lambda -1)/lambda

hist(spad_23_DB_out$bc_value)
skewness(spad_23_DB_out$bc_value, na.rm = TRUE)
qqnorm(spad_23_DB_out$bc_value, main='Normal')
qqline(spad_23_DB_out$bc_value)
shapiro.test(spad_23_DB_out$bc_value)

# sqrt
spad_23_DB_out$sqrt_value <- sqrt(spad_23_DB_out$value)

hist(spad_23_DB_out$sqrt_value)
skewness(spad_23_DB_out$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_DB_out$sqrt_value, main='Normal')
qqline(spad_23_DB_out$sqrt_value)
shapiro.test(spad_23_DB_out$sqrt_value)
```

2024 only: The dataset is non-parametric with a lambda between 1 and 2, indicating a boxcox or squared. Neither are successful, though
```{r}
spad_24_DB_out <- subset(spad_DB_out, year == "2024")

#original dataset
hist(spad_24_DB_out$value)
skewness(spad_24_DB_out$value, na.rm = TRUE)
qqnorm(spad_24_DB_out$value, main='Normal')
qqline(spad_24_DB_out$value)
shapiro.test(spad_24_DB_out$value)

#boxcox
bc <- boxcox(lm(spad_24_DB_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_24_DB_out$bc_value <- (spad_24_DB_out$value ^ lambda -1)/lambda

hist(spad_24_DB_out$bc_value)
skewness(spad_24_DB_out$bc_value, na.rm = TRUE)
qqnorm(spad_24_DB_out$bc_value, main='Normal')
qqline(spad_24_DB_out$bc_value)
shapiro.test(spad_24_DB_out$bc_value)

# log
spad_24_DB_out$sq_value <- spad_24_DB_out$value^2

hist(spad_24_DB_out$sq_value)
skewness(spad_24_DB_out$sq_value, na.rm = TRUE)
qqnorm(spad_24_DB_out$sq_value, main='Normal')
qqline(spad_24_DB_out$sq_value)
shapiro.test(spad_24_DB_out$sq_value)


```

#### collards

##### outliers removed

The original dataset is non-parametric. Lambda is between 0 and 0.5, indicating that a square root or boxcox transformation would be best suited, but neither results in a normal distribution
```{r}
#original dataset
hist(spad_FC$value)
skewness(spad_FC$value, na.rm = TRUE)
qqnorm(spad_FC$value, main='Normal')
qqline(spad_FC$value)
shapiro.test(spad_FC$value)

#boxcox
bc <- boxcox(lm(spad_FC$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_FC$bc_value <- (spad_FC$value ^ lambda -1)/lambda

hist(spad_FC$bc_value)
skewness(spad_FC$bc_value, na.rm = TRUE)
qqnorm(spad_FC$bc_value, main='Normal')
qqline(spad_FC$bc_value)
shapiro.test(spad_FC$bc_value)

# sqrt
spad_FC$sqrt_value <- sqrt(spad_FC$value)

hist(spad_FC$sqrt_value)
skewness(spad_FC$sqrt_value, na.rm = TRUE)
qqnorm(spad_FC$sqrt_value, main='Normal')
qqline(spad_FC$sqrt_value)
shapiro.test(spad_FC$sqrt_value)


```

2023 only: The dataset is non-parametric. Lambda is between 0.5 and 1, indicating a sqrt or boxcox transformation would be most appropriate. Neither achieves a normal distribution though
```{r}
spad_23_FC <- subset(spad_FC, year == "2023")

#original dataset
hist(spad_23_FC$value)
skewness(spad_23_FC$value, na.rm = TRUE)
qqnorm(spad_23_FC$value, main='Normal')
qqline(spad_23_FC$value)
shapiro.test(spad_23_FC$value)

#boxcox
bc <- boxcox(lm(spad_23_FC$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_FC$bc_value <- (spad_23_FC$value ^ lambda -1)/lambda

hist(spad_23_FC$bc_value)
skewness(spad_23_FC$bc_value, na.rm = TRUE)
qqnorm(spad_23_FC$bc_value, main='Normal')
qqline(spad_23_FC$bc_value)
shapiro.test(spad_23_FC$bc_value)

# sqrt
spad_23_FC$sqrt_value <- sqrt(spad_23_FC$value)

hist(spad_23_FC$sqrt_value)
skewness(spad_23_FC$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_FC$sqrt_value, main='Normal')
qqline(spad_23_FC$sqrt_value)
shapiro.test(spad_23_FC$sqrt_value)
```

2024 only: normal distribution!
```{r}
spad_24_FC <- subset(spad_FC, year == "2024")

#original dataset
hist(spad_24_FC$value)
skewness(spad_24_FC$value, na.rm = TRUE)
qqnorm(spad_24_FC$value, main='Normal')
qqline(spad_24_FC$value)
shapiro.test(spad_24_FC$value)

```


##### including outliers

The dataset is non-parametric, with a lambda close to -1, indicating an inverse square root, inverse, or boxcox will be most appropriate. None achieve a normal distribution
```{r}
#original dataset
hist(spad_FC_out$value)
skewness(spad_FC_out$value, na.rm = TRUE)
qqnorm(spad_FC_out$value, main='Normal')
qqline(spad_FC_out$value)
shapiro.test(spad_FC_out$value)

#boxcox
bc <- boxcox(lm(spad_FC_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_FC_out$bc_value <- (spad_FC_out$value ^ lambda -1)/lambda

hist(spad_FC_out$bc_value)
skewness(spad_FC_out$bc_value, na.rm = TRUE)
qqnorm(spad_FC_out$bc_value, main='Normal')
qqline(spad_FC_out$bc_value)
shapiro.test(spad_FC_out$bc_value)

# inverse sqrt
spad_FC_out$in_sqrt_value <- 1/sqrt(spad_FC_out$value)

hist(spad_FC_out$in_sqrt_value)
skewness(spad_FC_out$in_sqrt_value, na.rm = TRUE)
qqnorm(spad_FC_out$in_sqrt_value, main='Normal')
qqline(spad_FC_out$in_sqrt_value)
shapiro.test(spad_FC_out$in_sqrt_value)

# inverse 
spad_FC_out$inverse_value <- 1/(spad_FC_out$value)

hist(spad_FC_out$inverse_value)
skewness(spad_FC_out$inverse_value, na.rm = TRUE)
qqnorm(spad_FC_out$inverse_value, main='Normal')
qqline(spad_FC_out$inverse_value)
shapiro.test(spad_FC_out$inverse_value)
```

2023 only: The dataset is non-parametric. Lambda is between 0.5 and 1, indicating a sqrt or boxcox transformation would be most appropriate. Neither achieve a normal distribution though
```{r}
spad_23_FC_out <- subset(spad_FC_out, year == "2023")

#original dataset
hist(spad_23_FC_out$value)
skewness(spad_23_FC_out$value, na.rm = TRUE)
qqnorm(spad_23_FC_out$value, main='Normal')
qqline(spad_23_FC_out$value)
shapiro.test(spad_23_FC_out$value)

#boxcox
bc <- boxcox(lm(spad_23_FC_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_23_FC_out$bc_value <- (spad_23_FC_out$value ^ lambda -1)/lambda

hist(spad_23_FC_out$bc_value)
skewness(spad_23_FC_out$bc_value, na.rm = TRUE)
qqnorm(spad_23_FC_out$bc_value, main='Normal')
qqline(spad_23_FC_out$bc_value)
shapiro.test(spad_23_FC_out$bc_value)

# sqrt
spad_23_FC_out$sqrt_value <- sqrt(spad_23_FC_out$value)

hist(spad_23_FC_out$sqrt_value)
skewness(spad_23_FC_out$sqrt_value, na.rm = TRUE)
qqnorm(spad_23_FC_out$sqrt_value, main='Normal')
qqline(spad_23_FC_out$sqrt_value)
shapiro.test(spad_23_FC_out$sqrt_value)
```

2024 only: The dataset is non-parametric with a lambda between 0 and -0.5, indicating a boxcox, log, or inverse sqrt transformation would be most appropriate. None are successful, though
```{r}
spad_24_FC_out <- subset(spad_FC_out, year == "2024")

#original dataset
hist(spad_24_FC_out$value)
skewness(spad_24_FC_out$value, na.rm = TRUE)
qqnorm(spad_24_FC_out$value, main='Normal')
qqline(spad_24_FC_out$value)
shapiro.test(spad_24_FC_out$value)

#boxcox
bc <- boxcox(lm(spad_24_FC_out$value ~ 1))
lambda <- bc$x[which.max(bc$y)]
spad_24_FC_out$bc_value <- (spad_24_FC_out$value ^ lambda -1)/lambda

hist(spad_24_FC_out$bc_value)
skewness(spad_24_FC_out$bc_value, na.rm = TRUE)
qqnorm(spad_24_FC_out$bc_value, main='Normal')
qqline(spad_24_FC_out$bc_value)
shapiro.test(spad_24_FC_out$bc_value)

# log
spad_24_FC_out$log_value <- log10(spad_24_FC_out$value)

hist(spad_24_FC_out$log_value)
skewness(spad_24_FC_out$log_value, na.rm = TRUE)
qqnorm(spad_24_FC_out$log_value, main='Normal')
qqline(spad_24_FC_out$log_value)
shapiro.test(spad_24_FC_out$log_value)

# inverse square root
spad_24_FC_out$in_sqrt_value <- 1/sqrt(spad_24_FC_out$value)

hist(spad_24_FC_out$in_sqrt_value)
skewness(spad_24_FC_out$in_sqrt_value, na.rm = TRUE)
qqnorm(spad_24_FC_out$in_sqrt_value, main='Normal')
qqline(spad_24_FC_out$in_sqrt_value)
shapiro.test(spad_24_FC_out$in_sqrt_value)

```

## Weekly yield

### Visualizations by sampling date

#### Marketable yield
```{r}
#visualized each year separately, by sampling for each crop/treatment - this would need a lot of work
ggplot(subset(yield, year == 2023 & crop == "AS"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))
ggplot(subset(yield, year == 2023 & crop == "DB"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))
ggplot(subset(yield, year == 2023 & crop == "FC"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))


ggplot(subset(yield, year == 2024 & crop == "AS"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))
ggplot(subset(yield, year == 2024 & crop == "DB"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))
ggplot(subset(yield, year == 2024 & crop == "FC"), aes(x = as.factor(date_collected), y = marketable_g, fill = treatment)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45))

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield, crop == "AS"), aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield, crop == "AS"), aes(x = treatment, y = marketable_g)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = treatment, y = marketable_g)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = treatment, y = marketable_g)) + geom_boxplot()

```

#### Percent marketable
```{r}
#visualized each year separately, by sampling for each crop/treatment - this would need a lot of work
ggplot(subset(yield_wk, year == 2023), aes(x = week, y = per_market, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)
ggplot(subset(yield_wk, year == 2024), aes(x = week, y = per_market, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield_wk, crop == "AS"), aes(x = year, y = per_market, fill = treatment)) + geom_boxplot() 
ggplot(subset(yield_wk, crop == "DB"), aes(x = year, y = per_market, fill = treatment)) + geom_boxplot()
ggplot(subset(yield_wk, crop == "FC"), aes(x = year, y = per_market, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield_wk, crop == "AS"), aes(x = treatment, y = per_market)) + geom_boxplot() 
ggplot(subset(yield_wk, crop == "DB"), aes(x = treatment, y = per_market)) + geom_boxplot()
ggplot(subset(yield_wk, crop == "FC"), aes(x = treatment, y = per_market)) + geom_boxplot()

```

#### Unmarketable yield
```{r}
#visualized each year separately, by sampling for each crop/treatment - this would need a lot of work
ggplot(subset(yield, year == 2023), aes(x = as.factor(date_collected), y = unmarketable_g, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)
ggplot(subset(yield, year == 2024), aes(x = as.factor(date_collected), y = unmarketable_g, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield, crop == "AS"), aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield, crop == "AS"), aes(x = treatment, y = unmarketable_g)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = treatment, y = unmarketable_g)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = treatment, y = unmarketable_g)) + geom_boxplot()

```

#### Total yield
```{r}
#visualized each year separately, by sampling for each crop/treatment - this would need a lot of work
ggplot(subset(yield, year == 2023), aes(x = as.factor(date_collected), y = total_g, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)
ggplot(subset(yield, year == 2024), aes(x = as.factor(date_collected), y = total_g, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield, crop == "AS"), aes(x = year, y = total_g, fill = treatment)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = year, y = total_g, fill = treatment)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = year, y = total_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield, crop == "AS"), aes(x = treatment, y = total_g)) + geom_boxplot() 
ggplot(subset(yield, crop == "DB"), aes(x = treatment, y = total_g)) + geom_boxplot()
ggplot(subset(yield, crop == "FC"), aes(x = treatment, y = total_g)) + geom_boxplot()

```


## Annual Yield

### Final visualizations

#### Yield
```{r}
# Strawberries
yield_yr_AS_vis <- yield_yr_AS %>%
                   dplyr::select(c(1:8)) %>%
                   pivot_longer(cols = c('marketable_g', 'unmarketable_g', 
                                         'total_g'),
                                names_to = 'type',
                                values_to = 'yield_g') %>%
                   mutate(type = factor(type, levels = c('marketable_g', 
                                                         'unmarketable_g', 
                                                         'total_g')))
          

ggplot(subset(yield_yr_AS_vis, year == "2023"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()

ggplot(subset(yield_yr_AS_vis, year == "2024"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()


# Beans
yield_yr_DB_vis <- yield_yr_DB %>%
                   dplyr::select(c(1:8)) %>%
                   pivot_longer(cols = c('marketable_g', 'unmarketable_g', 
                                         'total_g'),
                                names_to = 'type',
                                values_to = 'yield_g') %>%
                   mutate(type = factor(type, levels = c('marketable_g', 
                                                         'unmarketable_g', 
                                                         'total_g')))
          

ggplot(subset(yield_yr_DB_vis, year == "2023"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()

ggplot(subset(yield_yr_DB_vis, year == "2024"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()


# Collards
yield_yr_FC_vis <- yield_yr_FC %>%
                   dplyr::select(c(1:8)) %>%
                   pivot_longer(cols = c('marketable_g', 'unmarketable_g', 
                                         'total_g'),
                                names_to = 'type',
                                values_to = 'yield_g') %>%
                   mutate(type = factor(type, levels = c('marketable_g', 
                                                         'unmarketable_g', 
                                                         'total_g')))
          

ggplot(subset(yield_yr_FC_vis, year == "2023"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()

ggplot(subset(yield_yr_FC_vis, year == "2024"), 
       aes(x = type, y = yield_g, fill = treatment)) + 
  geom_boxplot()
  

```
#### Percent marketable
```{r}
# Strawberries
ggplot(yield_yr_AS, aes(x = year, y = per_market, fill = treatment)) + geom_boxplot() 

# Beans
ggplot(yield_yr_DB, aes(x = year, y = per_market, fill = treatment)) + geom_boxplot() 

# Collards
ggplot(yield_yr_FC, aes(x = year, y = per_market, fill = treatment)) + geom_boxplot()
```


### Analysis

#### Strawberries

##### Marketable yield

Visualizations
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_AS, aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot() 

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_AS, aes(x = treatment, y = marketable_g)) + geom_boxplot() 

```


Overall: We consistently see that there is a significant difference in yield between years, so they will be analyzed separately
```{r}
# There is a significant difference for between BM and SM/CM, and year, but no interaction
# the assumptions are...somewhat met using the transformed dataset. assumptions are not met with the original dataset
aov <- aov(bc_marketable ~ treatment*year, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM for the best AIC, we get the isSingular error
model <- lmer(bc_marketable ~ treatment*year + (1 | block), data = yield_yr_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```

```{r}
#If we look at individual variables, there is not a significant difference for treatment
aov <- aov(bc_marketable ~ treatment, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_yr_AS)

#year is always significant
aov <- aov(bc_marketable ~ year, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ year, data = yield_yr_AS)

# If we try an LMM for year, we get the isSingular error
model <- lmer(bc_marketable ~ year + (1 | block), data = yield_yr_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)
```

2023 only
```{r}

# 2023: there was not a significant difference between mulch treatments for strawberry marketable yield. 
aov <- aov(marketable_g ~ treatment, data = yield_23_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_23_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(marketable_g ~ treatment + (1 | block), data = yield_23_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```


2024 only
```{r}
# 2024: there are nearly significant differences between BM and CM/SM
aov <- aov(marketable_g ~ treatment, data = yield_24_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

#nearly significant difference between BM and CM/SM
kruskal.test(marketable_g ~ treatment, data = yield_24_AS)
dunnTest(marketable_g ~ treatment, data = yield_24_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(marketable_g ~ treatment + (1 | block), data = yield_24_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Percent marketable

Visualizations
```{r}

#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_AS, aes(x = year, y = per_market, fill = treatment)) + geom_boxplot() 

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_AS, aes(x = treatment, y = per_market)) + geom_boxplot() 

```

The overall dataset is stubbornly non-parametric, so only KW tests are performed and years were analyzed separately
```{r}
# There is a significant difference between years
kruskal.test(per_market ~ year, data = yield_yr_AS)

# There is not a significant difference in percent marketable strawberry yield over both years
kruskal.test(per_market ~ treatment, data = yield_yr_AS)
```

2023 only: the dataset is normal, so we can do both ANOVA and KW. There are no significant differences between treatments
```{r}
#there is not a significant difference between treatments. model assumptions are met.
aov <- aov(per_market ~ treatment, data = yield_23_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# But still doing a KW, since 2024 is non-parametric. there is no difference between treatments
kruskal.test(per_market ~ treatment, data = yield_23_AS)

# If we try an LMM, there's still no differences between treatments and block is not a significant random effect
model <- lmer(per_market ~ treatment + (1 | block), data = yield_23_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only: The dataset is non-parametric, so only KW tests are performed
```{r}
# 2024: There was a significant difference between CM and BM for percent marketable strawberry yield

kruskal.test(per_market ~ treatment, data = yield_24_AS)
dunnTest(per_market ~ treatment, data = yield_24_AS)

```


##### Unmarketable yield

Visualization
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_AS, aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot() 

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_AS, aes(x = treatment, y = unmarketable_g)) + geom_boxplot() 

```
Overall, there was a significant difference between years but not treatments
```{r}
# There is a significant difference between years but not treatment. It's iffy whether the model assumptions are met
aov <- aov(bc_unmarketable ~ treatment*year, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM for the best AIC, we get the isSingular error
model <- lmer(bc_unmarketable ~ treatment*year + (1 | block), data = yield_yr_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)


```


```{r}
# Even when I look at year individually, there is a significant difference
aov <- aov(bc_unmarketable ~ year, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ year, data = yield_yr_AS)

# If we try an LMM for year, we also see a significant difference between years
model <- lmer(bc_unmarketable ~ year + (1 | block), data = yield_yr_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

# Even if I separate them into single predictor variables, there is no difference between treatments. 
aov <- aov(bc_unmarketable ~ treatment, data = yield_yr_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = yield_yr_AS)

# If we try an LMM for year, we get the isSingular error
model <- lmer(bc_unmarketable ~ treatment + (1 | block), data = yield_yr_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)


```

2023 only: no differences

```{r}

# no significant difference
aov <- aov(unmarketable_g ~ treatment, data = yield_23_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = yield_23_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(unmarketable_g ~ treatment + (1 | block), data = yield_23_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```

2024 only: no significant differences, KW probably most reliable
```{r}
# no significant difference
aov <- aov(bc_unmarket ~ treatment, data = yield_24_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = yield_24_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(bc_unmarket ~ treatment + (1 | block), data = yield_24_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```


##### Total yield

Visualizations
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_AS, aes(x = year, y = total_g, fill = treatment)) + geom_boxplot() 

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_AS, aes(x = treatment, y = total_g)) + geom_boxplot() 

```

```{r}


# There was not a significant difference between mulch treatments for strawberry total yield in 2023 or 2024
kruskal.test(total_g ~ treatment, data = subset(yield_yr_AS, year == "2023"))
kruskal.test(total_g ~ treatment, data = subset(yield_yr_AS, year == "2024"))
dunnTest(total_g ~ treatment, data = subset(yield_yr_AS, year == "2024"))
```


Overall: the dataset is non-parametric, so only doing kruskal-wallis tests. There are no differences between treatments, but the years are significantly different
```{r}
# There is not a significant difference in total strawberry yield across both years
kruskal.test(total_g ~ treatment, data = yield_yr_AS)

# There is a significant difference between years for total yield
kruskal.test(total_g ~ year, data = yield_yr_AS)
```
2023 only: no significant differences
```{r}
# 2023: there is a significant difference between bare soil and the mulches
aov <- aov(total_g ~ treatment, data = yield_23_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# there is not a significant difference between treatments
kruskal.test(total_g ~ treatment, data = yield_23_AS)
dunnTest(total_g ~ treatment, data = yield_23_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(total_g ~ treatment + (1 | block), data = yield_23_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```

2024 only: mixed results, but ANOVA best reflects the figure
```{r}
# 2024: there is a significant difference between bare soil and the mulches
aov <- aov(total_g ~ treatment, data = yield_24_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# there is not a significant difference between treatments
kruskal.test(total_g ~ treatment, data = yield_24_AS)
dunnTest(total_g ~ treatment, data = yield_24_AS)

# If we try an LMM, we get the isSingular error
model <- lmer(total_g ~ treatment + (1 | block), data = yield_24_AS)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)
```

#### Beans

##### Marketable yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield_yr, crop == "DB"), aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield_yr, crop == "DB"), aes(x = treatment, y = marketable_g)) + geom_boxplot()

```

Overall:

```{r}
# While the dataset is non-parametric, it seems to meet assumptions. I tried the boxcox transformed version (which is also not normally distributed), and it definitely did not meet assumptions. There is a difference between years, but not treatments 
aov <- aov(marketable_g ~ treatment*year, data = yield_yr_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM for the best AIC, it shows some odd results (namely to do with one output saying there is a significant difference between BM and SM, and the other not)
model <- lmer(marketable_g ~ treatment*year + (1 | block), data = yield_yr_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment*year)

```

```{r}
# I tried ANOVAs with treatment and with both original and transformed datsets, and none met model assumptions
# There is not a significant difference between treatments in marketable bean yield across both years
kruskal.test(marketable_g ~ treatment, data = yield_yr_DB)

# there is a significant difference between years. Tried the transformed data (which is also not normally distributed) as well, but it did not meet model assumptions
aov <- aov(marketable_g ~ year, data = yield_yr_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ year, data = yield_yr_DB)

# The LMM results in an isSingular error
model <- lmer(marketable_g ~ year + (1 | block), data = yield_yr_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```



2023 only
```{r}

# 2023: there is a nearly significant difference between BM and SM
aov <- aov(marketable_g ~ treatment, data = yield_23_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_23_DB)
dunnTest(marketable_g ~ treatment, data = yield_23_DB)

# If we try an LMM, we get the isSingular error
model <- lmer(marketable_g ~ treatment + (1 | block), data = yield_23_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only
```{r}
# there is no significant difference between treatments
aov <- aov(bc_marketable ~ treatment, data = yield_24_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_24_DB)
dunnTest(marketable_g ~ treatment, data = yield_24_DB)

# LMM:
model <- lmer(bc_marketable ~ treatment + (1 | block), data = yield_24_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Percent marketable

Visualizations:
```{r}

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield_yr, crop == "DB"), aes(x = year, y = per_market, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield_yr, crop == "DB"), aes(x = treatment, y = per_market)) + geom_boxplot()

```
Overall: bare soil is less than mulches
```{r}
# There is a nearly significant difference in percent marketable bean yield over both years. Percent marketable is lower for bare soil than mulches
kruskal.test(per_market ~ treatment, data = yield_yr_DB)
dunnTest(per_market ~ treatment, data = yield_yr_DB)

# There is not a significant difference between years for percent marketable yield
kruskal.test(per_market ~ year, data = yield_yr_DB)
```

Individual years: literally 100% was marketable in 2023. In 2024, there's a difference between bare soil and straw mulch
```{r}
# 2023: Pretty sure everything was 100%
kruskal.test(per_market ~ treatment, data = yield_23_DB)

# 2024: Bare soil is significantly less than straw, nearly significantly less than cardboard
kruskal.test(per_market ~ treatment, data = yield_24_DB)
dunnTest(per_market ~ treatment, data =yield_24_DB)

```


##### Unmarketable yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield_yr, crop == "DB"), aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield_yr, crop == "DB"), aes(x = treatment, y = unmarketable_g)) + geom_boxplot()

```

Overall:
```{r}
# There are nearly significant differences comparing BM and the mulches
kruskal.test(unmarketable_g ~ treatment, data = yield_yr_DB)
dunnTest(unmarketable_g ~ treatment, data = yield_yr_DB)

# There is not a significant difference between years for unmarketable yield
kruskal.test(unmarketable_g ~ year, data = yield_yr_DB)
```


Individual years
```{r}
# 2023: all 0
kruskal.test(unmarketable_g ~ treatment, data = yield_23_DB)

# 2024: 
kruskal.test(unmarketable_g ~ treatment, data = yield_24_DB)
dunnTest(unmarketable_g ~ treatment, data = yield_24_DB)
```
##### Total yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_DB, aes(x = year, y = total_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_DB, aes(x = treatment, y = total_g)) + geom_boxplot()

```

Overall: Differences between years (same results as marketable yield)

```{r}
# While the dataset is non-parametric, it seems to meet assumptions. I tried the boxcox transformed version (which is also not normally distributed), and it definitely did not meet assumptions. There is a difference between years, but not treatments 
aov <- aov(total_g ~ treatment*year, data = yield_yr_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM for the best AIC, it shows some odd results (namely to do with one output saying there is a significant difference between BM and SM, and the other not)
model <- lmer(total_g ~ treatment*year + (1 | block), data = yield_yr_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment*year)

```

Significant difference between years, not between treatments
```{r}
# I tried ANOVAs with treatment and with both original and transformed datsets, and none met model assumptions
# There is not a significant difference between treatments in total bean yield across both years
kruskal.test(total_g ~ treatment, data = yield_yr_DB)

# there is a significant difference between years. Tried the transformed data (which is also not normally distributed) as well, but it did not meet model assumptions
aov <- aov(total_g ~ year, data = yield_yr_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ year, data = yield_yr_DB)

# The LMM results in an isSingular error
model <- lmer(total_g ~ year + (1 | block), data = yield_yr_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```


2023 only
```{r}

# 2023: there is a nearly significant difference between BM and SM
aov <- aov(total_g ~ treatment, data = yield_23_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ treatment, data = yield_23_DB)
dunnTest(total_g ~ treatment, data = yield_23_DB)

# If we try an LMM, we get the isSingular error
model <- lmer(total_g ~ treatment + (1 | block), data = yield_23_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only: no differences between treatments
```{r}
# there is no significant difference between treatments
aov <- aov(bc_total ~ treatment, data = yield_24_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ treatment, data = yield_24_DB)

# LMM:
model <- lmer(bc_total ~ treatment + (1 | block), data = yield_24_DB)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


#### Collards

##### Marketable yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_FC, aes(x = year, y = marketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_FC, aes(x = treatment, y = marketable_g)) + geom_boxplot()

```


Overall
```{r}
# There is not a significant difference in marketable collards yield across years or treatments
aov <- aov(marketable_g ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM for the best AIC, we get the isSingular error
model <- lmer(marketable_g ~ treatment*year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}

# I can check for interactions, because it's normally distributed - but there are none
aov <- aov(marketable_g ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_yr_FC)

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(marketable_g ~ treatment + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

# There is NOT a significant difference between years for marketable yield
aov <- aov(marketable_g ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ year, data = yield_yr_FC)

# If we try an LMM for year, we get the isSingular error
model <- lmer(marketable_g ~ year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```

2023 only: 
```{r}

# 2023: there was not a significant difference between mulch treatments for collard marketable yield. 
aov <- aov(cubic_market ~ treatment, data = yield_23_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = yield_23_FC)

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(cubic_market ~ treatment + (1 | block), data = yield_23_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only
```{r}

# 2024: 
aov <- aov(marketable_g ~ treatment, data = yield_24_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(marketable_g ~ treatment, data = subset(yield_yr_FC, year == "2024"))

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(marketable_g ~ treatment + (1 | block), data = yield_24_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```



##### Percent marketable

Visualizations:
```{r}

#sampling combined, visualized by crop/treatment for each year
ggplot(subset(yield_yr, crop == "FC"), aes(x = year, y = per_market, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(subset(yield_yr, crop == "FC"), aes(x = treatment, y = per_market)) + geom_boxplot()

```

```{r}
# There is not a significant difference in percent marketable collard yield over both years
aov <- aov(per_market ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(per_market ~ treatment, data = yield_yr_FC)

# There is a significant difference between years for marketable yield
aov <- aov(per_market ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(per_market ~ year, data = yield_yr_FC)

# I can check for interactions, because it's normally distributed - there are some, but they don't give me more useful information than just analyzing the years separately
aov <- aov(per_market ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

# 2023: there was not a significant difference between mulch treatments percent marketable collard yield
aov <- aov(per_market ~ treatment, data = subset(yield_yr_FC, year == "2023"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(per_market ~ treatment, data = subset(yield_yr_FC, year == "2023"))

# 2024: there was not a significant difference between mulch treatments percent marketable collard yield
aov <- aov(per_market ~ treatment, data = subset(yield_yr_FC, year == "2024"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(per_market ~ treatment, data = subset(yield_yr_FC, year == "2024"))

```


Overall
```{r}
# There is not a significant difference in percent marketable collards yield for treatment, but there is a difference between years
aov <- aov(per_market ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM, block is not significant
model <- lmer(per_market ~ treatment*year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}

# there is not a significant difference between treatments
aov <- aov(per_market ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(per_market ~ treatment, data = yield_yr_FC)

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(per_market ~ treatment + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

# There is a significant difference between years for percent marketable yield
aov <- aov(per_market ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(per_market ~ year, data = yield_yr_FC)

# If we try an LMM for year, block is not a significant random effect
model <- lmer(per_market ~ year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```

2023 only: 
```{r}

# no significant difference between treatments
aov <- aov(per_market ~ treatment, data = yield_23_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(per_market ~ treatment, data = yield_23_FC)

# If we try an LMM for treatment, block is not a significant random effect
model <- lmer(per_market ~ treatment + (1 | block), data = yield_23_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only
```{r}

# 2024: tried the transformed dataset as well, and it didn't make a huge difference in model quality
aov <- aov(per_market ~ treatment, data = yield_24_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(per_market ~ treatment, data = subset(yield_yr_FC, year == "2024"))

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(per_market ~ treatment + (1 | block), data = yield_24_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


##### Unmarketable yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_FC, aes(x = year, y = unmarketable_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_FC, aes(x = treatment, y = unmarketable_g)) + geom_boxplot()

```


Overall
```{r}
# honestly none of the distributions are great. there is a significant differences between years
aov <- aov(bc_unmarketable ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)


# If we try an LMM, we get the isSingular error
model <- lmer(bc_unmarketable ~ treatment*year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
# there is not a significant difference between treatments
aov <- aov(bc_unmarketable ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = yield_yr_FC)

# If we try an LMM for treatment, block is not a significant random effect
model <- lmer(bc_unmarketable ~ treatment + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

# There is NOT a significant difference between years for marketable yield
aov <- aov(bc_unmarketable ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ year, data = yield_yr_FC)

# If we try an LMM for year, we get the isSingular error
model <- lmer(bc_unmarketable ~ year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```

2023 only: 
```{r}

# no difference between treatments 
aov <- aov(cubic_unmarketable ~ treatment, data = yield_23_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = yield_23_FC)

# If we try an LMM for treatment, we get a convergence error
model <- lmer(cubic_unmarketable ~ treatment + (1 | block), data = yield_23_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only
```{r}

# No difference between treatments 
aov <- aov(unmarketable_g ~ treatment, data = yield_24_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(unmarketable_g ~ treatment, data = subset(yield_yr_FC, year == "2024"))

# If we try an LMM for treatment, block is not a significant random effect
model <- lmer(unmarketable_g ~ treatment + (1 | block), data = yield_24_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```




##### Total yield

Visualizations:
```{r}
#sampling combined, visualized by crop/treatment for each year
ggplot(yield_yr_FC, aes(x = year, y = total_g, fill = treatment)) + geom_boxplot()

#sampling and year combined, visualized by crop/treatment. 
ggplot(yield_yr_FC, aes(x = treatment, y = total_g)) + geom_boxplot()

```

```{r}
# There is not a significant difference in total collard yield across both years
aov <- aov(total_g ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(total_g ~ treatment, data = yield_yr_FC)

# There is a significant difference between years for total yield
aov <- aov(total_g ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(total_g ~ year, data = yield_yr_FC)

# Checking for interactions - there are none
aov <- aov(total_g ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

# There was not a significant difference between mulch treatments for collard total yield in 2023 or 2024
aov <- aov(total_g ~ treatment, data = subset(yield_yr_FC, year == "2023"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(total_g ~ treatment, data = subset(yield_yr_FC, year == "2023"))

aov <- aov(total_g ~ treatment, data = subset(yield_yr_FC, year == "2024"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(total_g ~ treatment, data = subset(yield_yr_FC, year == "2024"))

```


Overall
```{r}
# There is not a significant difference in treatment, but there is between years
aov <- aov(total_g ~ treatment*year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

# If we try an LMM, we don't see the difference between years
model <- lmer(total_g ~ treatment*year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}

# no difference between treatments
aov <- aov(total_g ~ treatment, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ treatment, data = yield_yr_FC)

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(total_g ~ treatment + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

# There is a significant difference between years
aov <- aov(total_g ~ year, data = yield_yr_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ year, data = yield_yr_FC)

# If we try an LMM for year, block is not a significant random effect
model <- lmer(total_g ~ year + (1 | block), data = yield_yr_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ year)

```

2023 only: 
```{r}

# no difference between treatments
aov <- aov(cubic_total ~ treatment, data = yield_23_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ treatment, data = yield_23_FC)

# If we try an LMM for treatment, we get the isSingular error
model <- lmer(cubic_total ~ treatment + (1 | block), data = yield_23_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


2024 only
```{r}

# 2024: no treatment differences
aov <- aov(total_g ~ treatment, data = yield_24_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)
plot(aov)

kruskal.test(total_g ~ treatment, data = subset(yield_yr_FC, year == "2024"))

# If we try an LMM for treatment, block is not a significant random effect
model <- lmer(total_g ~ treatment + (1 | block), data = yield_24_FC)
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

## Foliar Chlorophyll

TRY THE ANALYSIS WITH BOTH DATASETS

### Visualization

Most relevant visual for my analysis thus far

```{r}

#sampling combined, visualized by crop/treatment for each year
ggplot(spad, aes(x = crop, y = value, fill = treatment)) + geom_boxplot() + facet_wrap(~year)

```

Other visualizations

```{r}

#visualized each year separately, by sampling for each crop/treatment
ggplot(subset(spad, year == 2023), aes(x = sampling, y = value, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)
ggplot(subset(spad, year == 2024), aes(x = sampling, y = value, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)

#years combined, visualized by sampling for each crop/treatment. REVISE THIS LATER, since there are a different number of sampling dates in each year
ggplot(spad, aes(x = sampling, y = value, fill = treatment)) + geom_boxplot() + facet_wrap(~crop)

#sampling and year combined, visualized by crop/treatment. 
ggplot(spad, aes(x = crop, y = value, fill = treatment)) + geom_boxplot()

#crops combined, year visualized by sampling/treatment
ggplot(spad, aes(x = sampling, y = value, fill = treatment)) + geom_boxplot() + facet_wrap(~year)

#treatments combined, year visualized by sampling/crop
ggplot(spad, aes(x = sampling, y = value, fill = crop)) + geom_boxplot() + facet_wrap(~year)

#crops and sampling combined, visualized by treatment for each year
ggplot(spad, aes(x = year, y = value, fill = treatment)) + geom_boxplot()

#treatments and sampling combined, visualized by crop for each year
ggplot(spad, aes(x = year, y = value, fill = crop)) + geom_boxplot()

# just treatments
ggplot(spad, aes(x = treatment, y = value)) + geom_boxplot()

#just crops
ggplot(spad, aes(x = crop, y = value)) + geom_boxplot()
```


### Pre-analysis

This was me running some initial tests before my meeting with Nora and Mary
```{r}
#across the whole data set, there is a difference between crops
kruskal.test(value ~ year, data = spad)
kruskal.test(value ~ treatment, data = spad)
kruskal.test(value ~ crop, data = spad)

#within each crop, there is a difference between years
kruskal.test(value ~ year, data = subset(spad, crop == "AS"))
kruskal.test(value ~ year, data = subset(spad, crop == "DB"))
kruskal.test(value ~ year, data = subset(spad, crop == "FC"))

#within each crop, there is only a difference between treatments for AS
kruskal.test(value ~ treatment, data = subset(spad, crop == "AS"))
kruskal.test(value ~ treatment, data = subset(spad, crop == "DB"))
kruskal.test(value ~ treatment, data = subset(spad, crop == "FC"))


#within a crop-year combination, there is a significant difference between treatments for AS in 2023, between DB in 2024, and between FC in 2024
kruskal.test(value ~ treatment, data = subset(spad, crop == "AS" & year == "2023"))
kruskal.test(value ~ treatment, data = subset(spad, crop == "AS" & year == "2024"))

kruskal.test(value ~ treatment, data = subset(spad, crop == "DB" & year == "2023"))
kruskal.test(value ~ treatment, data = subset(spad, crop == "DB" & year == "2024"))

kruskal.test(value ~ treatment, data = subset(spad, crop == "DB" & year == "2023"))
kruskal.test(value ~ treatment, data = subset(spad, crop == "DB" & year == "2024"))

```
### Analysis

#### Strawberries

##### ANOVA & KW
```{r}
#Across the whole data set, there is an interaction between treatment and year, so will analyze years separately
aov <- aov(value ~ treatment*year, data = spad_AS)
summary(aov)
TukeyHSD(aov)
AIC(aov)

# In 2023, bare soil was significantly different from straw and cardboard. I find the same results using KW with the df that includes potential outliers 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023"))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023"))

# In 2024, there was not a significant difference between treatments, regardless of whether I ran the ANOVA/no-outliers or KW/with outliers. 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024"))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024"))
```

##### Linear Mixed Models

rANOVA indicates that block is a significant random effect (p = 0.006) for 2023. emmeans shows that bare soil is significantly different from cardboard mulch (p = 0.001) and straw mulch (p = 0.05)
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

Block is not a significant random effect for 2024
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Should I look at sampling?

Sampling is significant as a random effect in 2023

```{r}
model <- lmer(value ~ treatment + (1 | sampling), data = subset(spad_AS, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(value ~ treatment + (1 | sampling/block), data = subset(spad_AS, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

```{r}
model <- lmer(value ~ treatment + (1 | sampling), data = subset(spad_AS, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(value ~ treatment + (1 | sampling/block), data = subset(spad_AS, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


##### Sampling Point 1

```{r}

# 2023: no significant differences between treatments 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 1))

# 2024: straw was significantly different from bare soil and cardboard
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 1))
```
2023: no significant differences between treatments 
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: straw was significantly different from bare soil and cardboard
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 2

```{r}

# 2023: bare soil is significantly different from bare soil and straw 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 2))

# 2024: cardboard was significantly different from bare soil and straw
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 2))
```


2023: bare soil is significantly different from cardboard and straw
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: cardboard is significantly different from bare soil and straw
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


##### Sampling Point 3

```{r}

# 2023: cardboard is significantly different from bare soil and straw
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 3))

# 2024: no significant differences between treatments
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 3))
```


2023: cardboard is significantly different from straw and bare soil
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 4

```{r}

# 2023: cardboard is significantly different from bare soil 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 4))

# 2024: no significant differences between treatments
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 4))
```


2023: cardboard is significantly different from straw and bare soil
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


##### Sampling Point 5

```{r}

# 2023:  no significant difference between treatments
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 5))

# 2024: 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2024" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2024" & sampling == 5))
```


2023: no significant difference between treatments
The data here is not normally distributed
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: 
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2024" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 6

```{r}

# 2023:  straw mulch is significantly different from cardboard 
aov <- aov(value ~ treatment, data = subset(spad_AS, year == "2023" & sampling == 6))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 6))
dunnTest(value ~ treatment, data = subset(spad_AS_out, year == "2023" & sampling == 6))

```


2023: no significant difference between treatments
The data here is not normally distributed
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_AS, year == "2023" & sampling == 6))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


#### Beans

##### ANOVA & KW
```{r}
#Across the whole data set, there is an interaction between treatment and year, so will analyze years separately
aov <- aov(value ~ treatment*year, data = spad_DB)
summary(aov)
TukeyHSD(aov)
AIC(aov)

# In 2023, there were no significant differences between treatments
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023"))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023"))

# In 2024, straw and cardboard were significantly different
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024"))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024"))
```

##### Linear Mixed Models

rANOVA indicates that block is a significant random effect (p = 0.02) for 2023. No significant difference between treatments
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

Block is not a significant random effect for 2024
```{r}
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Should I look at sampling?

Sampling is significant as a random effect in 2023

```{r}
model <- lmer(value ~ treatment + (1 | sampling), data = subset(spad_DB, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(value ~ treatment + (1 | sampling/block), data = subset(spad_DB, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

```{r}
model <- lmer(value ~ treatment + (1 | sampling), data = subset(spad_DB, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(value ~ treatment + (1 | sampling/block), data = subset(spad_DB, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 1

2023: cardboard is significantly different from bare soil
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 1))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: cardboard is significantly different from bare soil and straw mulch
```{r}

# ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 1))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 2

2023: no significant difference between treatments
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 2))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 2))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 3

2023: no difference between treatments
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 3))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 3))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 4

2023: no significant difference between treatments
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 4))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: SM is significantly different from CM and BM according to ANOVA, but not KW
```{r}

# ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 4))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 5

2023: Bare soil is significantly different from CM according to LMM. ANOVA and KW show no differences between treatments
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 5))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: SM is significantly different from cardboard according to ANOVA and LMM, but not KW.
```{r}

# ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2024" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2024" & sampling == 5))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2024" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 6

2023: ANOVA and LMM show no signficant difference between treatments. KW shows a barely significant relationship between bare soil and cardboard
```{r}

#ANOVA
aov <- aov(value ~ treatment, data = subset(spad_DB, year == "2023" & sampling == 6))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 6))
dunnTest(value ~ treatment, data = subset(spad_DB_out, year == "2023" & sampling == 6))

#LMM
model <- lmer(value ~ treatment + (1 | block), data = subset(spad_DB, year == "2023" & sampling == 6))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


### Collards

#### ANOVA & KW
```{r}
#Across the whole data set, years are significantly different
aov <- aov(bc_value ~ treatment*year, data = spad_FC)
summary(aov)
TukeyHSD(aov)
AIC(aov)

# In 2023, there were no significant differences between treatments. This finding is the same for ANOVA/transformed; no-outliers, KW/untransformed, no-outliers; KW/untransformed, with outliers
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023"))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023"))

kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023"))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023"))

# In 2024, there were no significant differences between treatments. This finding is the same for ANOVA/transformed; no-outliers, KW/untransformed, no-outliers; KW/untransformed, with outliers
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024"))
summary(aov)
TukeyHSD(aov)
AIC(aov)

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024"))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024"))

kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024"))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024"))
```

#### Linear Mixed Models

rANOVA indicates that block is not significant. There are no differences between treatment.
```{r}
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

Block is not a significant random effect for 2024
```{r}
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)


```


#### Should I look at sampling?

```{r}
model <- lmer(bc_value ~ treatment + (1 | sampling), data = subset(spad_FC, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(bc_value ~ treatment + (1 | sampling/block), data = subset(spad_FC, year == "2023"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

```{r}
model <- lmer(bc_value ~ treatment + (1 | sampling), data = subset(spad_FC, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


```{r}
model <- lmer(bc_value ~ treatment + (1 | sampling/block), data = subset(spad_FC, year == "2024"))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```


#### Sampling Point 1

2023: no difference between treatments
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 1))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 1))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: SM and CM are significantly different according to the ANOVA, LMM, and the KW with outliers removed, but not the KW for the original data
```{r}

# ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 1))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 1))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 1))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 1))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024" & sampling == 1))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

#### Sampling Point 2

2023: no significant difference between treatments
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 2))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 2))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 2))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 2))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 2))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 2))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024" & sampling == 2))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 3

2023: CM is significantly different from straw and bare soil
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 3))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 3))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 3))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 3))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 3))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 3))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024" & sampling == 3))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 4

2023: straw is significantly different from bare soil and cardboard
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 4))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 4))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 4))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 4))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 4))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 4))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024" & sampling == 4))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

##### Sampling Point 5

2023: no significant difference between treatments
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 5))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 5))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```

2024: no significant difference between treatments
```{r}

# ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 5))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2024" & sampling == 5))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 5))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2024" & sampling == 5))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2024" & sampling == 5))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
##### Sampling Point 6

2023: 
```{r}

#ANOVA
aov <- aov(bc_value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 6))
summary(aov)
TukeyHSD(aov)
AIC(aov)

#KW
kruskal.test(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 6))
dunnTest(value ~ treatment, data = subset(spad_FC_out, year == "2023" & sampling == 6))

kruskal.test(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 6))
dunnTest(value ~ treatment, data = subset(spad_FC, year == "2023" & sampling == 6))

#LMM
model <- lmer(bc_value ~ treatment + (1 | block), data = subset(spad_FC, year == "2023" & sampling == 6))
AIC(model)
summary(model)

#extract random effects and residual values
re <- ranef(model)
resid <- augment(model)

#generate qqplot
plot(re)

#generate plot of fitted vs. residual values
ggplot(resid, aes(x = .fitted, y = .resid)) + geom_point() + stat_smooth(se = F)

#ranked likelihood test
ranova(model)

emmeans(model, pairwise ~ treatment)

```
